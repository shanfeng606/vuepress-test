## 其他

### 前端性能优化

**服务端：**

1. 使用 CDN，CDN 可以通过 DNS 负载均衡技术将用户的请求转移到就近的 cache 服务器上，提高请求返回速度;
2. 利用静态资源缓存，给返回头加上 Cache-Control 或者 Etag 头。

**网络：**

1. 通过雪碧图、合并请求等方法减少请求数；
2. 减少文件大小：压缩 CSS、JS 和图片，在服务器（Nginx）中开启 Gzip：也就是先在服务端进行压缩，再在客户端进行解压。

**客户端：**

1. 使用外联 CSS 和 JS，CSS 放头，JS 放在文档尾部，防止页面加载阻塞以减少对并发下载的影响，尽早给用户展示出页面；
2. JS: 使用事件委托、减少 repaint 和 Reflow，如设置 class 更新样式，将多次 DOM 操作改完使用 DOM fragment，使用代码拆分、延迟加载；
3. 颜色较为丰富的图片且文件较大的文件优先考虑 jpg；图标等颜色简单、文件体积不大、起修饰作用的图片，优先考虑 PNG8；颜色丰富且有半透明效果的考虑 PNG24 格式；
4. 减少回流、重绘。如通过批量更新元素减少重排次数，设置类 class 统一更新样式，在添加多个DOM节点时使用 DOM fargment 来避免页面多次重绘


### 什么是进程 线程

知乎的答案，很舒服

看了一遍排在前面的答案，类似”**进程是资源分配的最小单位，线程是CPU调度的最小单位“**这样的回答感觉太抽象，都不太容易让人理解。

做个简单的比喻：进程=火车，线程=车厢

- 线程在进程下行进（单纯的车厢无法运行）
- 一个进程可以包含多个线程（一辆火车可以有多个车厢）
- 不同进程间数据很难共享（一辆火车上的乘客很难换到另外一辆火车，比如站点换乘）
- 同一进程下不同线程间数据很易共享（A车厢换到B车厢很容易）
- 进程要比线程消耗更多的计算机资源（采用多列火车相比多个车厢更耗资源）
- 进程间不会相互影响，一个线程挂掉将导致整个进程挂掉（一列火车不会影响到另外一列火车，但是如果一列火车上中间的一节车厢着火了，将影响到所有车厢）
- 进程可以拓展到多机，进程最多适合多核（不同火车可以开在多个轨道上，同一火车的车厢不能在行进的不同的轨道上）
- 进程使用的内存地址可以上锁，即一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。（比如火车上的洗手间）－"互斥锁"
- 进程使用的内存地址可以限定使用量（比如火车上的餐厅，最多只允许多少人进入，如果满了需要在门口等，等有人出来了才能进去）－“信号量”



### 说一下事件循环(Event Loop)？

JavaScript 中有 2 种任务：
**宏任务（macro-task）**: 同步 script (整体代码)，setTimeout 回调函数, setInterval 回调函数, I/O, UI rendering；
**微任务（micro-task）**: process.nextTick, Promise 回调函数，Object.observe，MutationObserver

其执行的顺序是这样的：

1. 首先 JavaScript 引擎会执行一个宏任务，注意这个宏任务一般是指主干代码本身，也就是目前的同步代码
2. 执行过程中如果遇到微任务，就把它添加到微任务任务队列中
3. 宏任务执行完成后，立即执行当前微任务队列中的微任务，直到微任务队列被清空
4. 微任务执行完成后，开始执行下一个宏任务
5. 如此循环往复，直到宏任务和微任务被清空



### 纯函数与非纯函数

纯函数

1、不改变源数组（没有副作用）；2、返回一个数组

concat    map   filter   slice

非纯函数

push pop shift unshift

foreach some every splice（剪接） reduce



### 阻止事件冒泡和默认行为

event.stopPropagation()

event.preventDefault()



### 什么是JSON

* json是一种数据格式，本质是一段字符串

* json格式和JS对象结构一致，对JS语言更友好

* window.JSON是一个全局对象：JSON.stringify   JSON.parse


 ###  使用`Object.prototype.toString`来判断值的类型

在任何值上调用`Object.prototype.toString`方法，都会返回一个 `[object NativeConstructorName]`格式的字符串。每个类在内部都有一个 `[[Class]]` 属性，这个属性中就指定了上述字符串中的构造函数名。

```js
Object.prototype.toString.call({name:'Jack'}) // [object Object]
Object.prototype.toString.call(function(){}) // [object Function]
Object.prototype.toString.call(/name/) // [object RegExp]
```

而对于基本类型：

```js
Object.prototype.toString.call('abc') // [object String]
Object.prototype.toString.call(12) // [object Number]
Object.prototype.toString.call(true) // [object Boolean]
```

基本类型值是没有构造函数的，为什么也能返回构造函数名呢？这是因为在`toString`被调用时 JavaScript 将基本类型值转换成了包装类型。

而对于`null`和`undefined`：

```js
Object.prototype.toString.call( null );			// "[object Null]"
Object.prototype.toString.call( undefined );	// "[object Undefined]"
```

虽然 JavaScript 中没有`Null()`和`Undefined`构造器，但是 JavaScript 也为我们处理这这两种情况。