## 其他

### 前端性能优化

**服务端：**

1. 使用 CDN，CDN 可以通过 DNS 负载均衡技术将用户的请求转移到就近的 cache 服务器上，提高请求返回速度
2. 利用静态资源缓存，给返回头加上 Cache-Control 或者 Etag 头

**网络：**

1. 通过雪碧图、合并请求等方法减少HTTP请求数
2. 减少文件大小：压缩 CSS、JS 和图片，在服务器（Nginx）中开启 Gzip：也就是先在服务端进行压缩，再在客户端进行解压

**客户端：**

1. 使用外联 CSS 和 JS，CSS 放头，JS 放在文档尾部，防止页面加载阻塞以减少对并发下载的影响，尽早给用户展示出页面
2. 懒加载（图片懒加载，上滑加载更多）
3. 对DOM查询进行缓存，频繁DOM操作，合并到一起插入DOM结构
4. 节流throttle   防抖 debounce
5. JS: 使用事件委托、减少重绘回流，如设置 class 更新样式







### 什么是进程 线程

知乎的答案，很舒服

看了一遍排在前面的答案，类似”**进程是资源分配的最小单位，线程是CPU调度的最小单位“**这样的回答感觉太抽象，都不太容易让人理解。

做个简单的比喻：进程=火车，线程=车厢

- 线程在进程下行进（单纯的车厢无法运行）
- 一个进程可以包含多个线程（一辆火车可以有多个车厢）
- 不同进程间数据很难共享（一辆火车上的乘客很难换到另外一辆火车，比如站点换乘）
- 同一进程下不同线程间数据很易共享（A车厢换到B车厢很容易）
- 进程要比线程消耗更多的计算机资源（采用多列火车相比多个车厢更耗资源）
- 进程间不会相互影响，一个线程挂掉将导致整个进程挂掉（一列火车不会影响到另外一列火车，但是如果一列火车上中间的一节车厢着火了，将影响到所有车厢）
- 进程可以拓展到多机，进程最多适合多核（不同火车可以开在多个轨道上，同一火车的车厢不能在行进的不同的轨道上）
- 进程使用的内存地址可以上锁，即一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。（比如火车上的洗手间）－"互斥锁"
- 进程使用的内存地址可以限定使用量（比如火车上的餐厅，最多只允许多少人进入，如果满了需要在门口等，等有人出来了才能进去）－“信号量”







### 纯函数与非纯函数

纯函数

1、不改变源数组（没有副作用）；2、返回一个数组

concat    map   filter   slice

非纯函数

push pop shift unshift

foreach some every splice（剪接） reduce



### 阻止事件冒泡和默认行为

event.stopPropagation()

event.preventDefault()



### 什么是JSON⭐

* json是一种数据格式，本质是一段字符串

* json格式和JS对象结构一致，对JS语言更友好

* window.JSON是一个全局对象：JSON.stringify   JSON.parse



### 什么是 JSONP，什么是 CORS（内容重复待定）

JSONP

1. JSONP是通过 script 标签加载数据的方式去获取数据当做 JS 代码来执行

2. 提前在页面上声明一个函数，函数名通过接口传参的方式传给后台，后台解析到函数名后在原始数据上「包裹」这个函数名，发送给前端。换句话说，JSONP 需要对应接口的后端的配合才能实现。



CORS()

CORS是一种协议，它用来约定服务端和客户端那些行为是被服务端允许的。尽管服务端是可以进行验证和认证的，但基本上这是由**客户端浏览器**来保证的。这些对行为的允许是放在应答包的header里面的。

它允许浏览器向跨源服务器，发出 XMLHttpRequest 请求，从而克服了 Ajax 只能同源使用的限制。

**以下是MDN的解释： **

跨域资源共享([CORS](https://developer.mozilla.org/zh-CN/docs/Glossary/CORS)) 是一种机制，它使用额外的 [HTTP](https://developer.mozilla.org/zh-CN/docs/Glossary/HTTP) 头来告诉浏览器 让运行在一个 origin (domain) 上的Web应用被准许访问来自不同源服务器上的指定的资源。当一个资源从与该资源本身所在的服务器**不同的域、协议或端口**请求一个资源时，资源会发起一个**跨域 HTTP 请求**。

比如，站点 http://domain-a.com 的某 HTML 页面通过 [ 的 src ](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/Img#Attributes)请求 http://domain-b.com/image.jpg。网络上的许多页面都会加载来自不同域的CSS样式表，图像和脚本等资源。

出于安全原因，浏览器限制从脚本内发起的跨源HTTP请求。 例如，XMLHttpRequest和Fetch API遵循同源策略。 这意味着使用这些API的Web应用程序只能从加载应用程序的同一个域请求HTTP资源，除非响应报文包含了正确CORS响应头。

 （译者注：这段描述不准确，并不一定是浏览器限制了发起跨站请求，也可能是跨站请求可以正常发起，但是返回结果被浏览器拦截了。）

跨域资源共享（ [CORS](https://developer.mozilla.org/zh-CN/docs/Glossary/CORS) ）机制允许 Web 应用服务器进行跨域访问控制，从而使跨域数据传输得以安全进行。现代浏览器支持在 API 容器中（例如 [`XMLHttpRequest`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest) 或 [Fetch](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) ）使用 CORS，以降低跨域 HTTP 请求所带来的风险。











### 理解TCP长连接（Keepalive）

长连接的环境下，进行一次数据交互后，很长一段时间内无数据交互时，客户端可能意外断电、死机、崩溃、重启，还是中间路由网络无故断开，这些TCP连接并未来得及正常释放，那么，连接的另一方并不知道对端的情况，它会一直维护这个连接，长时间的积累会导致非常多的半打开连接，造成端系统资源的消耗和浪费，且有可能导致在一个无效的数据链路层面发送业务数据，结果就是发送失败。所以服务器端要做到快速感知失败，减少无效链接操作，这就有了TCP的Keepalive（保活探测）机制。

**TCP Keepalive作用**

1. 探测连接的对端是否存活

在应用交互的过程中，可能存在以下几种情况：

  （1）客户端或服务器意外断电，死机，崩溃，重启。

  （2）中间网络已经中断，而客户端与服务器并不知道。

​    利用保活探测功能，可以探知这种对端的意外情况，从而保证在意外发生时，可以释放半打开的TCP连接。

2. 防止中间设备因超时删除连接相关的连接表

  中间设备如防火墙等，会为经过它的数据报文建立相关的连接信息表，并为其设置一个超时时间的定时器，如果超出预定时间，某连接无任何报文交互的话，

中间设备会将该连接信息从表中删除，在删除后，再有应用报文过来时，中间设备将丢弃该报文，从而导致应用出现异常。



**TCP Keepalive HTTP Keep-Alive 的关系**

在HTTP/1.0中，默认使用的是短连接。也就是说，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。如果客户端浏览器访问的某个HTML或其他类型的 Web页中包含有其他的Web资源，如JavaScript文件、图像文件、CSS文件等；当浏览器每遇到这样一个Web资源，就会建立一个HTTP会话。

但从 HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加上Connection、Keep-Alive字段

**HTTP协议**的Keep-Alive意图在于**TCP连接复用**，同一个连接上串行方式传递请求-响应数据；

**TCP**的Keepalive机制意图在于探测连接的对端是否存活（**探测保活**）。



**HTTP1.1  keep-alive重点：连接复用**

HTTP1.1规定了默认保持长连接，数据传输完成了保持TCP连接不断开（不发RST包、不四次握手），等待在同域名下继续用这个通道传输数据；相反的就是短连接。

![img](https://img2018.cnblogs.com/blog/285763/201906/285763-20190624163029209-1791008207.png)

在timeout空闲时间内，连接不会关闭，相同重复的request将复用原先的connection，减少握手的次数，大幅提高效率。

并非keep-alive的timeout设置时间越长，就越能提升性能。长久不关闭会造成过多的僵尸连接和泄露连接出现。





### 什么是柯里化 (curry)？

柯里化，即 currying，是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。

假设有一个`curry`函数可以将其他函数柯里化，其用法如下：

```js
// 一个接受两个参数的函数
const sum = (x, y) => x + y
// 用 20 来固定其中的一个参数，返回一个新的函数
const sumWith20 = curry(sum)(20)
// 再传入第二个参数
sumWith20(30) // 50
```



### JS模块化规范

AMD和CMD都是浏览器端的js模块化规范，分别由require.js和sea.js实现。 CommonJS是服务器端的js模块化规范，由NodeJS实现。



### 什么是单例模式

**单例模式：**保证一个类仅有一个实例，并提供一个访问它的全局访问点。

经典的**实现方式**是，创建一个类，这个类包含一个方法，这个方法在没有对象存在的情况下，将会创建一个新的实例对象。如果对象存在，这个方法只是返回这个对象的引用。

**实现代码:**

```js
var SingleTon = function(name){ //创建一个对象
    this.name = name;
    this.instance = null;   //通过这个变量来标志是否创建过对象
};
SingleTon.prototype.getName = function(){
    alert(this.name);
};
SingleTon.getInstance = function(name){
   if(!this.instance){
        this.instance = new SingleTon(name);   //在没有对象存在的情况下，将会创建一个新的实例对象
    }
    return this.instance;
};
 
var a = SingleTon.getInstance( 'instance1' );
var b = SinleTon.getInstance( 'instance2' );
alert( a === b);  //返回true
```





### 消息推送的几种实现方式

> **1、轮询**

客户端定时向服务器发送Ajax请求，服务器接到请求后马上返回响应信息，并关闭连接。

优点：后端程序编写比较容易
缺点：请求中大半是无用的，浪费带宽和服务器资源
实例：适用于小型应用



> **2.长轮询：**

客户端向服务器发送Ajax请求，服务器接到请求后Hold住连接，直到有新消息才返回响应信息，并关闭连接；客户端处理完响应信息后再向服务器发送新的请求。

优点：在无消息的情况下不会频繁的请求，耗费的资源少
缺点：服务器Hold住连接会消耗资源，返回数据顺序无法保证，难于管理和维护
实例：扫码登录，微信网页端获取消息等。



> **长连接：**

客户端和服务端建立长链接，基于http1.1 ,keepalive ,websocket,comet，iframe等，基于socket的需要维持心跳

优点：通信及时，通信模式采用双工，类似于打电话
缺点：服务端和客户端需要同时改造，当链接过多时，消耗服务端资源比较大。

使用场景：实时性要求很高，银行系统，股票系统等



### 面向对象的三大特性

**封装、继承、多态**

#### 一、封装：

封装：将内容封装到某个地方，之后调用的时候直接调用被封装在某处的内容

#### 二、继承：

继承，面向对象中的继承和现实生活中的继承相同，即：子可以继承父的内容。

#### 三：多态

多态的具体表现为方法重载和方法重写：

方法重载：重载是指不同的函数使用相同的函数名，但是函数的参数个数或类型不同。调用的时候根据函数的参数来区别不同的函数

方法重写：重写（也叫覆盖）是指在派生类中重新对基类中的虚函数（注意是虚函数）重新实现。即函数名和参数都一样，只是函数的实现体不一样





### 栈和队列的区别：

* 栈的插入和删除操作都是在一端进行的，而队列的操作却是在两端进行的。

* 栈是先进后出，队列是先进先出。 

* 栈只允许在表尾一端进行插入和删除，队列只允许在表尾一端进行插入，在表头一端进行删除。  



### 栈和堆的区别：

栈区：由编辑器自动分配释放，存放函数的参数值，局部变量的值等（基本类型值）。

堆区：由程序员分配释放，若程序员不释放，程序结束时可能有OS回收（引用类型值）。

栈（数据结构）：一种先进后出的数据结构。

堆（数据结构）：堆可以被看成是一棵树，如：堆排序。





### JS常见的几种设计模式

#### 单例模式

使用构造函数实例化的时候，不管实例化多少回，都实例化出同一个对象

- 一个构造函数一生只能 new 出一个对象
- 当我们使用构造函数，每一次 new 出来的对象 **属性/功能/方法** **完全一样** 的时候，我们把他设计成**单例模式**



#### 组合模式

举一个简单的例子，就像家里每个电器都有单独的开关，而组合模式就是设置一个`总开关`，这个开关可以控制家中所有电器的开关,这就是`组合模式`。



#### 观察者模式

- `观察者`观察着`被观察者`只要被观察者数据发生变化，观察者就要做一些事情
- 举个生动的例子，学生就是被观察者，老师就是观察者，只要学生上课状态不好，老师就会请家长。



#### 发布/订阅模式

> 分成三个状态

1. 订阅
2. 取消订阅
3. 发布

> 要实现 `订阅/取消订阅` 功能需要一个 `消息盒子{ }`

- 订阅就是往消息盒子里添加内容
- 取消订阅就是删除消息盒子里的内容
- 发布就是执行消息盒子里的内容



### For in

数组中也有for……in，相较于对象中的用法是有区别的：

**数组中**

```js
var arr = ['曹操','曹植','曹丕']
    for(i in arr){
    console.log(i) //0 1 2
    console.log(arr[i]) //曹操 曹植 曹丕
}
```

**对象中**

```js
var obj = new Object();
    obj = {
    father:'曹操',
    son:'曹植'
}
for(i in obj){
    console.log(i) ; //代表key值 father  son
    console.log(obj[i]) ; //代表vulue值 曹操  曹植
}
```





