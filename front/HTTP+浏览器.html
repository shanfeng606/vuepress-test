<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>HTTP/浏览器 | 前端知识图谱</title>
    <meta name="generator" content="VuePress 1.5.0">
    <link rel="icon" href="/vuepress-test/a.jpg">
    <meta name="description" content="">
    <link rel="preload" href="/vuepress-test/assets/css/0.styles.3a07e25f.css" as="style"><link rel="preload" href="/vuepress-test/assets/js/app.a9af0fa8.js" as="script"><link rel="preload" href="/vuepress-test/assets/js/2.f1d8a5fb.js" as="script"><link rel="preload" href="/vuepress-test/assets/js/9.ad2abf9c.js" as="script"><link rel="prefetch" href="/vuepress-test/assets/js/10.4c45adf6.js"><link rel="prefetch" href="/vuepress-test/assets/js/11.c08eee5b.js"><link rel="prefetch" href="/vuepress-test/assets/js/12.c4bf0acf.js"><link rel="prefetch" href="/vuepress-test/assets/js/13.91b14ed5.js"><link rel="prefetch" href="/vuepress-test/assets/js/14.b4fced57.js"><link rel="prefetch" href="/vuepress-test/assets/js/15.8d5cbeb0.js"><link rel="prefetch" href="/vuepress-test/assets/js/16.e9588432.js"><link rel="prefetch" href="/vuepress-test/assets/js/17.7217ca64.js"><link rel="prefetch" href="/vuepress-test/assets/js/18.91581d45.js"><link rel="prefetch" href="/vuepress-test/assets/js/3.e69ec39e.js"><link rel="prefetch" href="/vuepress-test/assets/js/4.22a09208.js"><link rel="prefetch" href="/vuepress-test/assets/js/5.37e26158.js"><link rel="prefetch" href="/vuepress-test/assets/js/6.3bcb7bf4.js"><link rel="prefetch" href="/vuepress-test/assets/js/7.284c6193.js"><link rel="prefetch" href="/vuepress-test/assets/js/8.d33bf6d7.js">
    <link rel="stylesheet" href="/vuepress-test/assets/css/0.styles.3a07e25f.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/vuepress-test/" class="home-link router-link-active"><img src="/vuepress-test/a.jpg" alt="前端知识图谱" class="logo"> <span class="site-name can-hide">前端知识图谱</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/vuepress-test/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="https://github.com/shanfeng606" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="http://www.shanfeng606.work" target="_blank" rel="noopener noreferrer" class="nav-link external">
  主博客
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/vuepress-test/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="https://github.com/shanfeng606" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="http://www.shanfeng606.work" target="_blank" rel="noopener noreferrer" class="nav-link external">
  主博客
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/vuepress-test/front/HTML.html" class="sidebar-link">HTML</a></li><li><a href="/vuepress-test/front/CSS.html" class="sidebar-link">CSS</a></li><li><a href="/vuepress-test/front/原生JS.html" class="sidebar-link">原生JS</a></li><li><a href="/vuepress-test/front/DOM.html" class="sidebar-link">DOM</a></li><li><a href="/vuepress-test/front/HTTP+浏览器.html" class="active sidebar-link">HTTP/浏览器</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vuepress-test/front/HTTP+浏览器.html#http-浏览器" class="sidebar-link">HTTP/浏览器</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vuepress-test/front/HTTP+浏览器.html#浏览器内核及其作用" class="sidebar-link">浏览器内核及其作用</a></li><li class="sidebar-sub-header"><a href="/vuepress-test/front/HTTP+浏览器.html#你是怎么理解http协议的" class="sidebar-link">你是怎么理解HTTP协议的</a></li><li class="sidebar-sub-header"><a href="/vuepress-test/front/HTTP+浏览器.html#http请求的内容" class="sidebar-link">HTTP请求的内容</a></li><li class="sidebar-sub-header"><a href="/vuepress-test/front/HTTP+浏览器.html#http响应的内容" class="sidebar-link">HTTP响应的内容</a></li><li class="sidebar-sub-header"><a href="/vuepress-test/front/HTTP+浏览器.html#http-状态码知道哪些？分别什么意思？" class="sidebar-link">HTTP 状态码知道哪些？分别什么意思？</a></li><li class="sidebar-sub-header"><a href="/vuepress-test/front/HTTP+浏览器.html#http请求方法" class="sidebar-link">HTTP请求方法</a></li><li class="sidebar-sub-header"><a href="/vuepress-test/front/HTTP+浏览器.html#https与http的一些区别" class="sidebar-link">HTTPS与HTTP的一些区别</a></li><li class="sidebar-sub-header"><a href="/vuepress-test/front/HTTP+浏览器.html#http2-0的特性" class="sidebar-link">HTTP2.0的特性</a></li><li class="sidebar-sub-header"><a href="/vuepress-test/front/HTTP+浏览器.html#http1-0与1-1区别" class="sidebar-link">HTTP1.0与1.1区别</a></li><li class="sidebar-sub-header"><a href="/vuepress-test/front/HTTP+浏览器.html#什么是拥塞控制" class="sidebar-link">什么是拥塞控制</a></li><li class="sidebar-sub-header"><a href="/vuepress-test/front/HTTP+浏览器.html#tcp建立连接的三次握手过程⭐" class="sidebar-link">TCP建立连接的三次握手过程⭐</a></li><li class="sidebar-sub-header"><a href="/vuepress-test/front/HTTP+浏览器.html#断开链接四次挥手⭐" class="sidebar-link">断开链接四次挥手⭐</a></li><li class="sidebar-sub-header"><a href="/vuepress-test/front/HTTP+浏览器.html#ssl-tls-握手过程（https通信过程）" class="sidebar-link">SSL/TLS 握手过程（HTTPS通信过程）</a></li><li class="sidebar-sub-header"><a href="/vuepress-test/front/HTTP+浏览器.html#get-和-post-的区别" class="sidebar-link">GET 和 POST 的区别</a></li><li class="sidebar-sub-header"><a href="/vuepress-test/front/HTTP+浏览器.html#跨域及解决办法" class="sidebar-link">跨域及解决办法</a></li><li class="sidebar-sub-header"><a href="/vuepress-test/front/HTTP+浏览器.html#jsonp的工作原理" class="sidebar-link">JSONP的工作原理</a></li><li class="sidebar-sub-header"><a href="/vuepress-test/front/HTTP+浏览器.html#cors-跨域资源共享" class="sidebar-link">CORS(跨域资源共享)</a></li><li class="sidebar-sub-header"><a href="/vuepress-test/front/HTTP+浏览器.html#cors和jsonp的区别" class="sidebar-link">CORS和JSONP的区别</a></li><li class="sidebar-sub-header"><a href="/vuepress-test/front/HTTP+浏览器.html#cookie、localstorage、sessionstorage区别与用法" class="sidebar-link">cookie、localStorage、sessionStorage区别与用法</a></li><li class="sidebar-sub-header"><a href="/vuepress-test/front/HTTP+浏览器.html#说一下cookie的内容有哪些" class="sidebar-link">说一下cookie的内容有哪些</a></li><li class="sidebar-sub-header"><a href="/vuepress-test/front/HTTP+浏览器.html#cookie跨域设置" class="sidebar-link">Cookie跨域设置</a></li><li class="sidebar-sub-header"><a href="/vuepress-test/front/HTTP+浏览器.html#cookie的弊端" class="sidebar-link">cookie的弊端</a></li><li class="sidebar-sub-header"><a href="/vuepress-test/front/HTTP+浏览器.html#web-storage和cookie的区别" class="sidebar-link">Web storage和cookie的区别</a></li><li class="sidebar-sub-header"><a href="/vuepress-test/front/HTTP+浏览器.html#cookie和session的区别" class="sidebar-link">Cookie和Session的区别</a></li><li class="sidebar-sub-header"><a href="/vuepress-test/front/HTTP+浏览器.html#从输入url到渲染出页面的整个过程⭐" class="sidebar-link">从输入url到渲染出页面的整个过程⭐</a></li><li class="sidebar-sub-header"><a href="/vuepress-test/front/HTTP+浏览器.html#html页面的加载顺序" class="sidebar-link">HTML页面的加载顺序</a></li><li class="sidebar-sub-header"><a href="/vuepress-test/front/HTTP+浏览器.html#dns域名解析的过程" class="sidebar-link">DNS域名解析的过程</a></li><li class="sidebar-sub-header"><a href="/vuepress-test/front/HTTP+浏览器.html#浏览器缓存的读取规则⭐" class="sidebar-link">浏览器缓存的读取规则⭐</a></li><li class="sidebar-sub-header"><a href="/vuepress-test/front/HTTP+浏览器.html#ajax的优缺点" class="sidebar-link">AJAX的优缺点</a></li><li class="sidebar-sub-header"><a href="/vuepress-test/front/HTTP+浏览器.html#使用ajax解决浏览器缓存问题" class="sidebar-link">使用Ajax解决浏览器缓存问题</a></li><li class="sidebar-sub-header"><a href="/vuepress-test/front/HTTP+浏览器.html#fetch与ajax" class="sidebar-link">Fetch与AJAX</a></li><li class="sidebar-sub-header"><a href="/vuepress-test/front/HTTP+浏览器.html#tcp和udp的区别-位于传输层" class="sidebar-link">TCP和UDP的区别(位于传输层)</a></li><li class="sidebar-sub-header"><a href="/vuepress-test/front/HTTP+浏览器.html#osi七层模型" class="sidebar-link">OSI七层模型</a></li><li class="sidebar-sub-header"><a href="/vuepress-test/front/HTTP+浏览器.html#window-onload-和-domcontentloaded-的区别" class="sidebar-link">window.onload 和 DOMContentLoaded 的区别</a></li><li class="sidebar-sub-header"><a href="/vuepress-test/front/HTTP+浏览器.html#请介绍下fetch发送2次请求的原因" class="sidebar-link">请介绍下fetch发送2次请求的原因</a></li><li class="sidebar-sub-header"><a href="/vuepress-test/front/HTTP+浏览器.html#浏览器中的常驻线程" class="sidebar-link">浏览器中的常驻线程</a></li><li class="sidebar-sub-header"><a href="/vuepress-test/front/HTTP+浏览器.html#网站的登录态是如何保持的，一个完整的登录流程是怎样实现的？" class="sidebar-link">网站的登录态是如何保持的，一个完整的登录流程是怎样实现的？</a></li><li class="sidebar-sub-header"><a href="/vuepress-test/front/HTTP+浏览器.html#cdn原理" class="sidebar-link">CDN原理</a></li></ul></li></ul></li><li><a href="/vuepress-test/front/Vue.html" class="sidebar-link">Vue</a></li><li><a href="/vuepress-test/front/Webpack.html" class="sidebar-link">Webpack</a></li><li><a href="/vuepress-test/front/安全.html" class="sidebar-link">安全</a></li><li><a href="/vuepress-test/front/编程题.html" class="sidebar-link">编程题</a></li><li><a href="/vuepress-test/front/手写题.html" class="sidebar-link">手写题</a></li><li><a href="/vuepress-test/front/算法.html" class="sidebar-link">算法母题</a></li><li><a href="/vuepress-test/front/其他.html" class="sidebar-link">其他</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="http-浏览器"><a href="#http-浏览器" class="header-anchor">#</a> HTTP/浏览器</h2> <h3 id="浏览器内核及其作用"><a href="#浏览器内核及其作用" class="header-anchor">#</a> 浏览器内核及其作用</h3> <p><strong>浏览器内核就是负责读取网页内容，整理讯息，计算网页的显示方式并显示页面.</strong></p> <table><thead><tr><th>浏览器</th> <th>内核</th> <th>备注</th></tr></thead> <tbody><tr><td>IE</td> <td>Trident</td> <td>IE、猎豹安全、360极速浏览器、百度浏览器</td></tr> <tr><td>firefox</td> <td>Gecko</td> <td>可惜这几年已经没落了，打开速度慢、升级频繁、猪一样的队友flash、神一样的对手chrome。</td></tr> <tr><td>Safari</td> <td>webkit</td> <td>从Safari推出之时起，它的渲染引擎就是Webkit，一提到 webkit，首先想到的便是 chrome，可以说，chrome 将 Webkit内核 深入人心，殊不知，Webkit 的鼻祖其实是 Safari。</td></tr> <tr><td>chrome</td> <td>Chromium/Blink</td> <td>在 Chromium 项目中研发 Blink 渲染引擎（即浏览器核心），内置于 Chrome 浏览器之中。Blink 其实是 WebKit 的分支。大部分国产浏览器最新版都采用Blink内核。二次开发</td></tr> <tr><td>Opera</td> <td>blink</td> <td>现在跟随chrome用blink内核。</td></tr></tbody></table> <h3 id="你是怎么理解http协议的"><a href="#你是怎么理解http协议的" class="header-anchor">#</a> 你是怎么理解HTTP协议的</h3> <p>HTTP（HyperText Transfer Protocol）协议是<strong>基于TCP的应用层协议</strong>，它不关心数据传输的细节，主要是用来规定客户端和服务端的数据传输格式，最初是用来向客户端传输HTML页面的内容。默认端口是80。</p> <blockquote><p>特点：</p></blockquote> <p><strong>1.HTTP协议是无状态的</strong></p> <p>就是说每次HTTP请求都是独立的，任何两个请求之间没有什么必然的联系。但是在实际应用当中并不是完全这样的，引入了Cookie和Session机制来关联请求。</p> <p><strong>2.多次HTTP请求</strong></p> <p>在客户端请求网页时多数情况下并不是一次请求就能成功的，服务端首先是响应HTML页面，然后浏览器收到响应之后发现HTML页面还引用了其他的资源，例如，CSS，JS文件，图片等等，还会自动发送HTTP请求这些需要的资源。现在的HTTP版本支持管道机制，可以同时请求和响应多个请求，大大提高了效率。</p> <p><strong>3.基于TCP协议</strong></p> <p>HTTP协议目的是规定客户端和服务端数据传输的格式和数据交互行为，并不负责数据传输的细节。底层是基于TCP实现的。现在使用的版本当中是默认持长连接的，也就是多次HTTP请求使用一个TCP连接。</p> <h3 id="http请求的内容"><a href="#http请求的内容" class="header-anchor">#</a> HTTP请求的内容</h3> <p><strong>请求行+请求头部+请求数据+空行</strong></p> <blockquote><p>请求行</p></blockquote> <p>请求的第一行是：方法、URL、HTTP协议版本    例如：GET /index.html HTTP/1.1</p> <blockquote><p>请求头(key value形式)</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>User-Agent：产生请求的浏览器类型。
Accept：客户端可识别的内容类型列表。
Host：主机地址
</code></pre></div><blockquote><p>请求数据</p></blockquote> <p>请求正文中可以包含用户提交的查询信息，在post方法中，将数据以key value形式发送请求</p> <blockquote><p>空行</p></blockquote> <p>发送回车符和换行符，通知服务器以下不再有请求头</p> <h3 id="http响应的内容"><a href="#http响应的内容" class="header-anchor">#</a> HTTP响应的内容</h3> <p><strong>响应消息行+响应消息头+响应消息正文</strong></p> <blockquote><p>响应消息行</p></blockquote> <p>包含协议/版本，响应状态码，对响应状态码的描述</p> <blockquote><p>响应消息头</p></blockquote> <p>服务器与客户端通信的暗码，告诉客户端该怎么执行某些操作</p> <blockquote><p>响应消息正文</p></blockquote> <p>和网页右键“查看源码”看到的内容一样</p> <p><strong>HTTP中确定报文结束的方法</strong>:</p> <ul><li><p><strong>关闭TCP连接</strong></p></li> <li><p><strong>通过<code>Content-Length</code>检测</strong></p></li></ul> <h3 id="http-状态码知道哪些？分别什么意思？"><a href="#http-状态码知道哪些？分别什么意思？" class="header-anchor">#</a> HTTP 状态码知道哪些？分别什么意思？</h3> <p>2XX 成功</p> <ul><li>200 OK</li> <li>204 No Content</li> <li>206 Partial Content</li></ul> <p>3XX 重定向</p> <ul><li>301 永久重定向</li> <li>302 临时重定向</li> <li>304 资源未修改</li></ul> <p>4XX 客户端错误</p> <ul><li>400 请求报文中有语法错误</li> <li>401 请求未经授权</li> <li>403 服务器拒绝访问</li> <li>404 资源未找到</li> <li>405 不允许的方法</li> <li>408 请求超时</li></ul> <p>5XX 服务器错误</p> <ul><li>500 仅仅告诉你服务器出错了，出了啥错咱也不知道</li> <li>502 错误网关，无效响应</li> <li>503 服务器忙碌无法响应</li> <li>504 网关超时</li></ul> <h3 id="http请求方法"><a href="#http请求方法" class="header-anchor">#</a> HTTP请求方法</h3> <p>GET：获取资源</p> <p>POST：传输实体文本</p> <p>HEAD：获得报文首部</p> <p>PUT：传输文件</p> <p>DELETE：删除文件</p> <p>OPTIONS：询问支持的方法</p> <p>TRACE：追踪路径</p> <p>CONNECT：要求用隧道协议连接代理</p> <h3 id="https与http的一些区别"><a href="#https与http的一些区别" class="header-anchor">#</a> HTTPS与HTTP的一些区别</h3> <ul><li>HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。</li> <li>HTTPS相对于HTTP加入了ssl层，所有传输的内容都经过加密的，安全但是耗时多。</li> <li>HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li></ul> <p><strong>CA   SSL    端口</strong></p> <h3 id="http2-0的特性"><a href="#http2-0的特性" class="header-anchor">#</a> HTTP2.0的特性</h3> <ul><li><p><strong>内容安全</strong>：http2.0是基于https的</p></li> <li><p><strong>二进制格式</strong>：http1.X的解析是基于文本的，http2.0将所有的传输信息分割为更小的消息和帧，并对他们<strong>采用二进制格式编码</strong></p></li> <li><p><strong>多路复用</strong>——只需一个连接即可实现并行（<strong>请求管道化，防止队头阻塞，多个请求合并到一个TCP</strong>）</p></li> <li><p><strong>首部压缩</strong>——使用<strong>首部表</strong>来跟踪和存储之前发送的键值对。对于相同的数据，不再重新通过每次请求和响应发送。每个新的首部键值对要么追加到当前表的末尾，要么替换表中之前的值。</p></li></ul> <p><strong>补充</strong>：HTTP2 主要解决的问题也是 TCP连接复用。但它比 keep-alive 更彻底，类似于通信工程里的时分复用，多个请求可以同时发送（不分先后），同时响应，解决了 队头阻塞（HOL blocking）的问题，极大提高效率。</p> <p>keep-alive 的 HTTP pipelining 相当于单线程的，而 HTTP2 相当于并发。]</p> <p><strong>http如何控制请求的数量</strong>：同一时间针对同一域名下的请求有一定数量限制。超过限制数目的请求会被阻塞</p> <h3 id="http1-0与1-1区别"><a href="#http1-0与1-1区别" class="header-anchor">#</a> <strong>HTTP1.0与1.1区别</strong></h3> <ul><li><p><strong>长连接</strong>  HTTP 1.0需要使用keep-alive参数来告知服务器端要建立一个长连接，而HTTP1.1默认支持长连接。</p></li> <li><p><strong>节约带宽</strong> HTTP 1.1支持只发送header信息(不带任何body信息)</p></li> <li><p><strong>HOST域</strong>  HTTP1.0是没有host域的，HTTP1.1才支持这个参数。</p></li></ul> <h3 id="什么是拥塞控制"><a href="#什么是拥塞控制" class="header-anchor">#</a> 什么是拥塞控制</h3> <p><strong>拥塞控制，就是在网络中发生拥塞时，减少向网络中发送数据的速度，防止造成恶性循环；同时在网络空闲时，提高发送数据的速度，最大限度地利用网络资源</strong>。</p> <p>说的简单点，就和堵车差不多，路就这么宽，来的车多了，自然过的就慢，所以在必要的时候要限号。</p> <p>https://www.cnblogs.com/tuyang1129/p/12439862.html</p> <h3 id="tcp建立连接的三次握手过程⭐"><a href="#tcp建立连接的三次握手过程⭐" class="header-anchor">#</a> TCP建立连接的三次握手过程⭐</h3> <p>[https://www.zhihu.com/search?type=content&amp;q=%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%204%E6%AC%A1%E6%8C%A5%E6%89%8B](https://www.zhihu.com/search?type=content&amp;q=三次握手 4次挥手)</p> <p><strong>三次握手</strong>：</p> <ul><li>首先服务器端处于LISTEN状态。</li> <li>当客户端想要建立连接时，他将发送一个SYN包，序列号假如为x。客户端进入SYN_SENT状态。</li> <li>当服务器端收到了这个SYN包，如果服务器同意建立连接，他将发送一个SYN，ACK包，序列号假如为y，确认号为x+1。服务器端进入SYN_RECD状态。</li> <li>当客户端收到了服务器端的SYN,ACK包，它将再次确认，向服务器发送一个ACK包，序列号为x+1，确认号为y+1。此时客户端进入ESTABLISHED状态。</li> <li>当服务器端收到了客户端的ACK包，也将进入ESTABLISHED状态。</li></ul> <p><strong>Q:为什么不能是2次握手</strong></p> <ul><li>为了实现可靠数据传输， TCP 协议的通信双方， 都必须维护一个序列号， 以标识发送出去的数据包中， 哪些是已经被对方收到的。 三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤</li> <li>如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认</li></ul> <h3 id="断开链接四次挥手⭐"><a href="#断开链接四次挥手⭐" class="header-anchor">#</a> 断开链接四次挥手⭐</h3> <p>刚开始双方都处于 establised 状态，假如是客户端先发起关闭请求，则：</p> <ul><li><p><strong>第一次挥手</strong>：客户端发送一个 FIN 报文，报文中会指定一个序列号x。此时客户端处于<strong>FIN_WAIT1</strong>(终止等待1)状态。</p></li> <li><p><strong>第二次挥手</strong>：服务端收到 FIN 之后，会发送 ACK 报文，且把x+ 1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 <strong>CLOSE_WAIT</strong>状态。</p></li> <li><p><strong>第三次挥手</strong>：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号y。此时服务端处于 <strong>LAST_ACK</strong> 的状态。</p></li> <li><p><strong>第四次挥手</strong>：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 y+ 1 作为自己 ACK 报文的序列号值，此时客户端处于 <strong>TIME_WAIT</strong> 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入<strong>CLOSED</strong> 状态</p></li> <li><p>服务端收到 ACK 报文之后，就处于关闭连接了，处于 <strong>CLOSED</strong> 状态。</p></li></ul> <h3 id="ssl-tls-握手过程（https通信过程）"><a href="#ssl-tls-握手过程（https通信过程）" class="header-anchor">#</a> SSL/TLS 握手过程（HTTPS通信过程）</h3> <p>阮一峰的例子：</p> <p>客户端：爱丽丝   、  服务端：鲍勃</p> <ul><li><p>第一步，爱丽丝给出协议版本号、一个客户端生成的随机数（Client random），以及客户端支持的加密方法。</p></li> <li><p>第二步，鲍勃确认双方使用的加密方法，并给出数字证书、以及一个服务器生成的随机数（Server random）。</p></li> <li><p>第三步，爱丽丝确认数字证书有效，然后生成一个新的随机数（Premaster secret），并使用数字证书中的公钥，加密这个随机数，发给鲍勃。</p></li> <li><p>第四步，鲍勃使用自己的私钥，获取爱丽丝发来的随机数（即Premaster secret）。</p></li> <li><p>第五步，爱丽丝和鲍勃根据约定的加密方法，使用前面的三个随机数，生成&quot;对话密钥&quot;（session key），用来加密接下来的整个对话过程。</p></li></ul> <h3 id="get-和-post-的区别"><a href="#get-和-post-的区别" class="header-anchor">#</a> GET 和 POST 的区别</h3> <p>语义上的区别，get用于获取数据，post用于提交数据。</p> <ul><li><p>Post多用于副作用（对服务器的资源进行改变），Get多用于无副作用</p></li> <li><p>Post 相对 Get 安全一点点，因为GET请求的数据会附在URL之后，以?分割URL和传输数据，参数之间以&amp;相连，</p> <p>POST把提交的数据则放置在是HTTP包的包体中。post易于防止CSRF。</p></li> <li><p>GET的长度受限于url的长度，而url的长度限制是特定的浏览器和服务器设置的，理论上GET的长度可以无限长。</p></li> <li><p>Post 支持更多的编码类型且不对数据类型限制，GET 只能进行 URL 编码，只能接收 ASCII 字符</p></li> <li><p>私密性的信息请求使用post，查询信息和可以想要通过url分享的信息使用get。</p></li></ul> <p><strong>副作用   参数位置  长度  编码类型</strong></p> <h3 id="跨域及解决办法"><a href="#跨域及解决办法" class="header-anchor">#</a> 跨域及解决办法</h3> <p>浏览器遵循<strong>同源政策</strong>（scheme(协议)、host(主机)和port(端口)都相同则为同源）</p> <p>当浏览器向目标 <code>URI</code>发<code>Ajax</code> 请求时，只要当前 <code>URL</code> 和目标 <code>URL</code> 不同源，则产生跨域，被称为<strong>跨域请求</strong>。</p> <p><strong>目的</strong> 主要是用来防止 CSRF 攻击的。简单点说，CSRF 攻击是利用用户的登录态发起恶意请求。
采用同源策略主要是因为安全。若非同源下的cookie等隐私数据可以被随意获取，非同源下的DOM可以的随意操作，ajax可以任意请求的话，用户的各种隐私势必泄露。</p> <h4 id="解决"><a href="#解决" class="header-anchor">#</a> <strong>解决</strong></h4> <blockquote><p>如果是像解决 ajax 无法提交跨域请求的问题，我们可以使用 jsonp、cors、websocket 协议、服务器代理来解决问题。</p></blockquote> <ol><li><strong>JSONP</strong> ，允许 script 加载第三方资源    只支持get。JSONP 本质不是 Ajax 请求，是 script 标签请求。JSONP 请求本质上是利用了 “Ajax请求会受到同源策略限制，而 script 标签请求不会” 这一点来绕过同源策略。</li> <li><strong>CORS</strong> 前后端协作设置请求头部，Access-Control-Allow-Origin 等头部信息</li> <li><strong>反向代理</strong>（nginx 服务内部配置 Access-Control-Allow-Origin ）</li> <li>使用 <strong>websocket 协议</strong>，这个协议没有同源限制。</li></ol> <blockquote><p>如果只是想要实现主域名下的不同子域名的跨域操作，我们可以使用设置 document.domain 来解决。</p> <p>比如a.test.com和b.test.com   只需要给页面添加document.domain='test.com'表示二级域名都相等就可以实现跨域</p></blockquote> <ol><li>document.domain + iframe跨域</li> <li>location.hash</li> <li>window.name + iframe跨域</li> <li>postMessage 跨域</li></ol> <h3 id="jsonp的工作原理"><a href="#jsonp的工作原理" class="header-anchor">#</a> JSONP的工作原理</h3> <p>JSONP</p> <ol><li><p>JSONP是通过 script 标签加载数据，获取的数据当做 JS 代码来执行，利用标签没有同源策略的限制（算是一个漏洞），来达到与第三方通信，从而实现跨域。只支持get</p></li> <li><p>提前在页面上声明一个函数，函数名通过接口传参的方式传给后台，后台解析到函数名后在原始数据上「包裹」这个函数名，发送给前端。换句话说，JSONP 需要对应接口的后端的配合才能实现。</p></li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&lt;</span>script<span class="token operator">&gt;</span>
	<span class="token comment">//jsonp回调方法，一定要写在jsonp请求前面</span>
	<span class="token keyword">function</span> <span class="token function">testjson</span><span class="token punctuation">(</span><span class="token parameter">txt</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token function">alert</span><span class="token punctuation">(</span>txt<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>script src <span class="token operator">=</span><span class="token string">&quot;/demo/testJsonp.shtml?callback=testjson&quot;</span> type<span class="token operator">=</span><span class="token string">&quot;text/javascript&quot;</span> <span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
</code></pre></div><h3 id="cors-跨域资源共享"><a href="#cors-跨域资源共享" class="header-anchor">#</a> CORS(跨域资源共享)</h3> <p><strong>CORS 全称是跨域资源共享（Cross-Origin Resource Sharing），是一种 AJAX 跨域请求资源的方式。</strong>
CORS与JSONP的使用目的相同，但是比JSONP更强大。JSONP只支持GET请求，CORS<strong>支持所有类型的HTTP请求</strong>。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。</p> <p>CORS 需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，因此我们只需要在服务器端配置就行。浏览器将 CORS 请求分成两类：简单请求和非简单请求。</p> <p><strong>对于简单请求</strong>，浏览器直接发出 CORS 请求。具体来说，就是会在<strong>头信息之中，增加一个 Origin 字段</strong>。Origin 字段用来说明本次请求来自哪个源。服务器根据这个值，决定是否同意这次请求。对于如果 Origin 指定的源，不在许可范围内，服务器会返回一个正常的 HTTP 回应。浏览器发现，这个回应的头信息没有包含 Access-Control-Allow-Origin 字段，就知道出错了，从而抛出一个错误，ajax 不会收到响应信息。如果成功的话会包含一些以 Access-Control- 开头的字段。</p> <p><strong>非简单请求</strong>，浏览器会先发出一次预检请求，来判断该域名是否在服务器的白名单中，如果收到肯定回复后才会发起请求。</p> <p>浏览器将CORS请求分成两类：<strong>简单请求</strong>和<strong>非简单请求</strong></p> <p>只要同时满足以下两大条件，就属于简单请求</p> <ul><li>请求方法是以下三种方法之一：</li></ul> <div class="language- extra-class"><pre class="language-text"><code>HEAD
GET
POST
</code></pre></div><ul><li>HTTP的头信息不超出以下几种字段：</li></ul> <div class="language- extra-class"><pre class="language-text"><code>Accept
Accept-Language
Content-Language
Last-Event-ID
Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain
</code></pre></div><p>不同时满足上面两个条件，就属于非简单请求。</p> <h3 id="cors和jsonp的区别"><a href="#cors和jsonp的区别" class="header-anchor">#</a> CORS和JSONP的区别</h3> <ul><li>JSONP只能实现GET请求，而CORS支持所有类型的HTTP请求。</li> <li>使用CORS，开发者可以使用普通的XMLHttpRequest发起请求和获得数据，比起JSONP有更好的错误处理。</li> <li>JSONP主要被老的浏览器支持，它们往往不支持CORS，而绝大多数现代浏览器都已经支持了CORS</li></ul> <h3 id="cookie、localstorage、sessionstorage区别与用法"><a href="#cookie、localstorage、sessionstorage区别与用法" class="header-anchor">#</a> cookie、localStorage、sessionStorage区别与用法</h3> <table><thead><tr><th>特性</th> <th><strong>cookie</strong></th> <th><strong>localStorage</strong></th> <th><strong>sessionStorage</strong></th> <th><strong>indexDB</strong></th></tr></thead> <tbody><tr><td>数据生命周期</td> <td>一般由服务器生成，可以设置过期时间</td> <td>除非被清理，否则一直存在</td> <td>页面关闭就清理</td> <td>除非被清理，否则一直存在</td></tr> <tr><td>数据存储大小</td> <td>4K</td> <td>5M</td> <td>5M</td> <td>无限</td></tr> <tr><td>与服务端通信</td> <td>每次都会携带在 header 中，对于请求性能影响</td> <td>不参与</td> <td>不参与</td> <td>不参与</td></tr></tbody></table> <p>localStorage 和 sessionStorage 都具有相同的操作方法，例如 <code>setItem()</code>、<code>getItem()</code> 和 <code>removeItem()</code> 等</p> <div class="language- extra-class"><pre class="language-text"><code>//添加修改数据
sessionStorage.setItem('key', 'value');
localStorage.setItem('key', 'value');
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>//获取数据
sessionStorage.getItem('key');
localStorage.getItem('key');
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>//移除数据
sessionStorage.removeItem('key');
localStorage.removeItem('key');
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>//全部清除
sessionStorage.clear();
localStorage.clear();
</code></pre></div><p>cookie</p> <div class="language- extra-class"><pre class="language-text"><code>//储存数据
window.document.cookie = 'xxx';
//取出数据
document.cookie
</code></pre></div><h3 id="说一下cookie的内容有哪些"><a href="#说一下cookie的内容有哪些" class="header-anchor">#</a> <strong>说一下cookie的内容有哪些</strong></h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token string">&quot;key=name; expires=Thu, 25 Feb 2016 04:18:00 GMT; domain=ppsc.sankuai.com; path=/; secure; HttpOnly&quot;</span>
</code></pre></div><p><strong>expires</strong></p> <p><code>expires</code>选项用来设置“cookie 什么时间内有效”。</p> <p><code>expires</code> 是 http/1.0协议中的选项，在新的http/1.1协议中<code>expires</code>已经由 <code>max-age</code> 选项代替，两者的作用都是限制cookie 的有效时间。</p> <p><strong>domain 和 path</strong></p> <p><code>domain</code>是域名，<code>path</code>是路径，两者加起来就构成了 URL，<code>domain</code>和<code>path</code>一起来限制 cookie 能被哪些 URL 访问。</p> <p>通过设置domain来实现cookie跨子域的问题</p> <div class="language-js extra-class"><pre class="language-js"><code>cookie<span class="token punctuation">.</span><span class="token function">setDomain</span><span class="token punctuation">(</span><span class="token string">&quot;test.com&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
</code></pre></div><p><strong>secure</strong></p> <p><code>secure</code>选项用来设置<code>cookie</code>只在确保安全的请求中才会发送。当请求是<code>HTTPS</code>或者其他安全协议时，包含 <code>secure</code> 选项的 <code>cookie</code>才能被发送至服务器。</p> <p><strong>httpOnly</strong></p> <p>这个选项用来设置<code>cookie</code>是否能通过 <code>js</code> 去访问。如果您在cookie中设置了HttpOnly属性，那么通过js脚本将无法读取到cookie信息，这样能有效的防止XSS攻击</p> <p>通俗地说，就是当一个用户通过 HTTP 协议访问一个服务器的时候，这个服务器会将一些 Key/Value 键值对返回给客户端浏览器，并给这些数据加上一些限制条件，在条件符合时这个用户下次访问这个服务器的时候，数据又被完整地带回给服务器。</p> <h3 id="cookie跨域设置"><a href="#cookie跨域设置" class="header-anchor">#</a> Cookie跨域设置</h3> <p>网页端中，对于跨域的 <code>XMLHttpRequest</code> 请求，需要设置<code>withCredentials</code> 属性为 true。</p> <p>同时服务端的响应中必须携带 <code>Access-Control-Allow-Credentials: true</code> 首部。如果服务端的响应中未携带<code>Access-Control-Allow-Credentials: true</code> 首部，浏览器将不会把响应的内容返回给发送者。</p> <p>JSONP</p> <p>nginx反向代理</p> <h3 id="cookie的弊端"><a href="#cookie的弊端" class="header-anchor">#</a> cookie的弊端</h3> <ul><li>cookie 有大小限制、每条cookie不能超过4kb</li> <li>cookies存在安全性问题、有可能被篡改</li> <li>有些数据不能存在客户端、例如表单不能重复提交</li> <li>cookie每次发送数据都会发送给服务端、造成不必要的浪费</li></ul> <h3 id="web-storage和cookie的区别"><a href="#web-storage和cookie的区别" class="header-anchor">#</a> <strong>Web storage和cookie的区别</strong></h3> <p><strong>----存储大小，服务器交互，方法属性</strong></p> <p>1、Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小是受限的，并且每次你请求一个新的页面的时候Cookie都会被发送过去，这样无形中浪费了带宽，另外cookie还需要指定作用域，不可以跨域调用。
2、除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要前端开发者自己封装setCookie，getCookie。
3、但是cookie也是不可以或缺的：cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生。</p> <h3 id="cookie和session的区别"><a href="#cookie和session的区别" class="header-anchor">#</a> Cookie和Session的区别</h3> <p>1、cookie数据存放在客户的浏览器上，session数据放在服务器上(可以理解为存在服务器上的缓存)。</p> <p>2、cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗，考虑到安全应当使用session。</p> <p>3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用cookie。</p> <p>4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。</p> <p>5、可以考虑将登陆信息等重要信息存放为session，其他信息如果需要保留，可以放在cookie中。</p> <p><strong>存放位置，安全，存储大小</strong></p> <p><strong>token认证机制</strong></p> <p>token与session的不同主要在①认证成功后，会对当前用户数据进行加密，<strong>生成一个加密字符串token</strong>，返还给客户端（服务器端并不进行保存）</p> <p>②浏览器会将接收到的token值存储在Local Storage中，（通过js代码写入Local Storage，通过js获取，并不会像cookie一样自动携带）</p> <p>③再次访问时服务器端对token值的处理：<strong>服务器对浏览器传来的token值进行解密</strong>，解密完成后进行用户数据的查询，如果查询成功，则通过认证，实现状态保持，所以，即时有了多台服务器，服务器也只是做了token的解密和用户数据的查询，它不需要在服务端去保留用户的认证信息或者会话信息，这就意味着基于token认证机制的应用不需要去考虑用户在哪一台服务器登录了，这就为应用的扩展提供了便利，解决了session扩展性的弊端。</p> <p><strong>session与token</strong></p> <p>方案 A ：我发给你一张身份证，但只是一张写着身份证号码的纸片。你每次来办事，我去后台查一下你的 id 是不是有效。
方案 B ：我发给你一张加密的身份证，以后你只要出示这张卡片，我就知道你一定是自己人。
就这么个差别。</p> <h3 id="从输入url到渲染出页面的整个过程⭐"><a href="#从输入url到渲染出页面的整个过程⭐" class="header-anchor">#</a> 从输入url到渲染出页面的整个过程⭐</h3> <p>DNS域名解析（先查找缓存） –&gt; 发起TCP的3次握手 –&gt; 建立TCP连接后发起http请求 –&gt; 服务器响应http请求，浏览器得到html代码 –&gt; 浏览器解析html代码，并请求html代码中的资源（如js、css、图片等） –&gt; 浏览器对页面进行渲染呈现给用户</p> <p><strong>加载过程</strong></p> <ul><li><p><code>DNS</code>解析：域名 --&gt; IP地址   (递归查询：从根域名服务器到顶级域名服务器再到极限域名服务器依次搜索哦对应目标域名的IP)</p></li> <li><p>浏览器根据IP地址向服务器发起<code>http</code>请求   (浏览器与服务器建立tcp连接（三次握手）)</p></li> <li><p>服务器处理<code>http</code>请求，并返回给浏览器</p></li></ul> <p><strong>渲染过程</strong></p> <ul><li>浏览器解析接收到 <code>HTML</code> 文件并转换为 <code>DOM</code> 树，确定节点的父子以及兄弟关系。（HTML-Token-DOM树）</li> <li>将 <code>CSS</code> 文件转换为 <code>CSSOM</code> 树，确定css属性之间的级联关系。</li> <li>生成 <code>DOM</code> 树和 <code>CSSOM</code> 树以后，就需要将这两棵树组合为渲染树，根据渲染树来进行布局，然后调用 <code>GPU</code> 绘制，合成图层，显示在屏幕上。</li> <li>遇到<code>&lt;script&gt;</code>则暂停渲染，优先加载并执行JS代码，完成再继续，直至把<code>Render Tree</code>渲染完成</li></ul> <h3 id="html页面的加载顺序"><a href="#html页面的加载顺序" class="header-anchor">#</a> HTML页面的加载顺序</h3> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>
        <span class="token comment">&lt;!-- 引用外部JS文件 --&gt;</span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>...........<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
        <span class="token comment">&lt;!--引用外部css样式 --&gt;</span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>.............<span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">&gt;</span></span><span class="token style"><span class="token language-css">
               ..............
        </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
               <span class="token operator">...</span><span class="token operator">...</span><span class="token operator">...</span><span class="token operator">...</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
               <span class="token operator">...</span><span class="token operator">...</span><span class="token operator">...</span><span class="token operator">...</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>从上到下运行，先解析head标签中的代码，</p> <p>（1) head标签中会包含一些引用外部文件的代码，从开始运行就会下载这些被引用的外部文件（css并行加载）</p> <p>​     当<strong>遇到script标签</strong>的时候，加载并执行JS代码</p> <p>（2）当head中代码解析完毕，会开始解析body中的代码</p> <p>​     如果此时head中引用的外部文件没有下载完，将会继续下载</p> <p>​     浏览器解析body代码中的元素，会按照head中声明一部分样式去解析</p> <p>​     如果此时遇到body标签中的<code>&lt;script&gt;</code>，同样会将控制权交给JavaScript引擎来解析JavaScript</p> <p>​     解析完毕后将控制权交还给浏览器渲染引擎。</p> <p>​     <strong>当body中的代码全部执行完毕、并且整个页面的css样式加载完毕后，css会重新渲染整个页面的html元素。</strong></p> <p>（3）按照之前的描述，<strong><code>&lt;script&gt;</code>写到body标签内靠后比较好，</strong></p> <p>​     因为JavaScript 会操作html元素， 如果在body加载完之前写JavaScript 会造成JavaScript 找不到页面元素</p> <p>​     但是我们经常将<code>&lt;script&gt;</code>写到head中，body中不会有大量的js代码，body中的html代码结构会比较清晰</p> <p>​     window.onload： 等待页面中的所有内容加载完毕之后才会执行</p> <p>​     $(document).ready()： 页面中所有DOM结构绘制完毕之后就能够执行</p> <p>​     可以这样理解：window.onload 和 $(document).ready()/$(function(){}); 相当于  写在body 内  最靠后的<code>&lt;script&gt;</code>代码段</p> <h3 id="dns域名解析的过程"><a href="#dns域名解析的过程" class="header-anchor">#</a> DNS域名解析的过程</h3> <p>解析流程就是<strong>分级查询</strong></p> <p>以[www.163.com]为例:</p> <ul><li>客户端打开浏览器，输入一个域名。比如输入[www.163.com]，这时，客户端会发出一个DNS请求到<strong>DNS本地服务器</strong>。本地DNS服务器一般都是你的网络接入服务器商提供，比如中国电信，中国移动。</li> <li>查询[www.163.com]的DNS请求到达本地DNS服务器之后，本地DNS服务器会首先查询它的缓存记录，如果缓存中有此条记录，就可以直接返回结果。如果没有，本地DNS服务器还要向<strong>DNS根服务器</strong>进行查询。</li> <li>根DNS服务器没有记录具体的域名和IP地址的对应关系，而是告诉本地DNS服务器，你可以到<strong>域服务器</strong>上去继续查询，并给出域服务器的地址。</li> <li>本地DNS服务器继续向域服务器发出请求，在这个例子中，请求的对象是.com域服务器。.com域服务器收到请求之后，也不会直接返回域名和IP地址的对应关系，而是<strong>告诉本地DNS服务器，你的域名的解析服务器的地址</strong>。</li> <li>最后，本地DNS服务器向<strong>域名的解析服务器</strong>发出请求，这时就能收到一个域名和IP地址对应关系，本地DNS服务器不仅要把IP地址返回给用户电脑，还要把这个对应关系保存在缓存中，以备下次别的用户查询时，可以直接返回结果，加快网络访问。</li></ul> <h3 id="浏览器缓存的读取规则⭐"><a href="#浏览器缓存的读取规则⭐" class="header-anchor">#</a> 浏览器缓存的读取规则⭐</h3> <p>它们的<strong>优先级</strong>是：(由上到下寻找，找到即返回；找不到则继续)</p> <ol><li>Service Worker   运行在 JavaScript 主线程之外，虽然由于脱离了浏览器窗体无法直接访问 DOM，但是它可以完成离线缓存、消息推送、网络代理等功能。</li> <li>Memory Cache（内存中的缓存）</li> <li>Disk Cache（硬盘中的缓存）</li> <li>网络请求</li></ol> <h4 id="强缓存："><a href="#强缓存：" class="header-anchor">#</a> 强缓存：</h4> <p>不会向服务器发送请求，直接从缓存中读取资源，状态码200。</p> <p>强缓存可以通过设置两种 HTTP Header 实现：<code>Expires</code> 和 <code>Cache-Control</code> 。</p> <p><code>Expires</code>设置一个日期，资源会过期，但受限于本地时间</p> <p><code>Cache-Control：max-age=30</code>  资源会在30秒后过期   <code>no-cache</code>必须先与服务器确认返回的响应是否被更改</p> <h4 id="协商缓存："><a href="#协商缓存：" class="header-anchor">#</a> 协商缓存：</h4> <p>当强制缓存失效(超过规定时间)时，就需要使用协商缓存，由服务器决定缓存内容是否失效。</p> <p>流程上说，浏览器先请求缓存数据库，返回一个缓存标识。之后浏览器拿这个标识和服务器通讯。如果缓存未失效，则返回 HTTP 状态码 304 表示继续使用，于是客户端继续使用缓存；如果失效，则返回新的数据和缓存规则，浏览器响应数据后，再把规则写入到缓存数据库。</p> <p>协商缓存有 2 组字段(不是两个)：</p> <p><strong>Last-Modified &amp; If-Modified-Since</strong></p> <ol><li><p>服务器通过 <code>Last-Modified</code> 字段告知客户端，资源最后一次被修改的时间</p></li> <li><p>下一次请求相同资源时时，浏览器从自己的缓存中找出“不确定是否过期的”缓存。因此在请求头中将上次的 <code>Last-Modified</code> 的值写入到请求头的 <code>If-Modified-Since</code> 字段</p></li> <li><p>服务器会将 <code>If-Modified-Since</code> 的值与 <code>Last-Modified</code> 字段进行对比。如果相等，则表示未修改，响应 304；反之，则表示修改了，响应 200 状态码，并返回数据。</p></li></ol> <p>但是他还是有一定缺陷的：</p> <ul><li>如果资源更新的速度是秒以下单位，那么该缓存是不能被使用的，因为它的时间单位最低是秒。</li> <li>如果文件是通过服务器动态生成的，那么该方法的更新时间永远是生成的时间，尽管文件可能没有变化，所以起不到缓存的作用。</li></ul> <p><strong>Etag &amp; If-None-Match</strong></p> <p>为了解决上述问题，出现了一组新的字段 <code>Etag</code> 和 <code>If-None-Match</code></p> <p><code>Etag</code> 存储的是文件的特殊标识(一般都是 hash 生成的)，服务器存储着文件的 <code>Etag</code> 字段。之后的流程和 <code>Last-Modified</code> 一致，只是 <code>Last-Modified</code> 字段和它所表示的更新时间改变成了 <code>Etag</code> 字段和它所表示的文件 hash，把 <code>If-Modified-Since</code> 变成了 <code>If-None-Match</code>。服务器同样进行比较，命中返回 304, 不命中返回新资源和 200。</p> <p><strong>Etag 的优先级高于 Last-Modified</strong></p> <p><strong>LM与Etag区别</strong></p> <p>LM根据文件修改时间来判断是否要重新返回整个文件，对应请求头 IF-M-S ，服务端和客户端进行对比，但是时间只能精确到秒，假如在这一秒之间恰好发生了变化就GG了。
E-tag则是对文件求MD5或者哈希值，绝对精确，只要有任何变化都能体现出来，这个算法貌似是server配置的</p> <h3 id="ajax的优缺点"><a href="#ajax的优缺点" class="header-anchor">#</a> AJAX的优缺点</h3> <p>优点：</p> <ul><li><p>最大的一点是<strong>页面无刷新</strong>，在页面内与服务器通信，给用户的体验非常好</p></li> <li><p>使用<strong>异步</strong>方式与服务器通信，不需要打断用户的操作，具有更加迅速的响应能力</p></li> <li><p><strong>减轻服务器和带宽的负担</strong> ，前端和后端负载平衡</p></li></ul> <p>缺点：</p> <ul><li><p>AJAX干掉了Back和History功能，即对浏览器机制的破坏</p></li> <li><p>AJAX安全问题</p></li> <li><p>对搜索引擎支持较弱</p></li></ul> <h3 id="使用ajax解决浏览器缓存问题"><a href="#使用ajax解决浏览器缓存问题" class="header-anchor">#</a> 使用<code>Ajax</code>解决浏览器缓存问题</h3> <p>我们都知道ajax能提高页面载入的速度主要的原因是通过ajax减少了重复数据的载入，也就是说在载入数据的同时将数据缓存到内存中，一旦数据被加载其中，只要我们没有刷新页面，这些数据就会一直被缓存在内存中，当我们提交 的<code>URL</code>与历史的<code>URL</code>一致时，就不需要提交给服务器，也就是不需要从服务器上面去获取数据，虽然这样降低了服务器的负载提高了用户的体验，但是我们不能获取最新的数据。为了保证我们读取的信息都是最新的，我们就需要禁止他的缓存功能。</p> <p><strong>禁止浏览器缓存功能有如下几种方法：</strong></p> <ol><li>在<code>ajax</code>发送请求前加上 <code>anyAjaxObj.setRequestHeader(&quot;If-Modified-Since&quot;,&quot;0&quot;)</code>。</li> <li>在<code>ajax</code>发送请求前加上 <code>anyAjaxObj.setRequestHeader(&quot;Cache-Control&quot;,&quot;no-cache&quot;)</code>。</li> <li>在<code>URL</code>后面加上一个随机数：<code>&quot;fresh=&quot; + Math.random()</code>;。</li> <li>在<code>URL</code>后面加上时间戳：<code>&quot;nowtime=&quot; + new Date().getTime()</code>;。</li> <li>如果是使用<code>jQuery</code>，直接这样就可以了<code>$.ajaxSetup({cache:false})</code>。这样页面的所有<code>ajax</code>都会执行这条语句就是不需要保存缓存记录。</li></ol> <h3 id="fetch与ajax"><a href="#fetch与ajax" class="header-anchor">#</a> Fetch与AJAX</h3> <p>XMLHttpRequest 是一个设计粗糙的 API，不符合关注分离（Separation of Concerns）的原则，配置和调用方式非常混乱，而且基于事件的异步模型写起来也没有现代的 Promise，generator/yield，async/await 友好。<a href="http://caibaojian.com/fetch-ajax.html" target="_blank" rel="noopener noreferrer">·<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>Fetch 的出现就是为了解决 XHR 的问题</p> <p>缺点：</p> <ul><li>有兼容问题的</li></ul> <ul><li><p>Fetch 请求默认是不带 cookie 的，需要设置 <code>fetch(url, {credentials: 'include'})</code></p></li> <li><p>服务器返回 400，500 错误码时并不会 reject，只有网络错误这些导致请求不能完成时，fetch 才会被 reject。</p></li></ul> <h3 id="tcp和udp的区别-位于传输层"><a href="#tcp和udp的区别-位于传输层" class="header-anchor">#</a> TCP和UDP的区别(位于传输层)</h3> <ul><li>TCP 是面向连接的，UDP 是面向无连接的</li> <li>UDP程序结构较简单</li> <li>TCP 是面向字节流的，UDP 是基于数据报的</li> <li>TCP 保证数据正确性，UDP 可能丢包</li> <li>TCP 保证数据顺序，UDP 不保证</li></ul> <p><strong>什么是面向连接，什么是面向无连接</strong></p> <p>在互通之前，面向连接的协议会先建立连接，如 TCP 有三次握手，而 UDP 不会</p> <p><strong>TCP 为什么是可靠连接</strong></p> <ul><li><p>TCP 报文头里面的序号能使 TCP 的数据按序到达</p></li> <li><p>报文头里面的确认序号能保证不丢包，累计确认及超时重传机制</p></li> <li><p>TCP 拥有流量控制及拥塞控制的机制</p></li></ul> <p>总结：<strong>UDP面向无连接  不可靠性  高效</strong></p> <h3 id="osi七层模型"><a href="#osi七层模型" class="header-anchor">#</a> OSI七层模型</h3> <p>osi七层模型可以说是面试必考基础了    <strong>物理系有一个人叫数据链路在网络上传输了一个会话来表示应用</strong></p> <p>从上到下分别是：</p> <p>应用层：特定应用的协议（电子邮件协议，远程登录协议，文件传输协议）  HTTP HTTPS  FTP DNS SMTP</p> <p>表示层：数据格式转换</p> <p>会话层：建立，解除会话</p> <hr> <p>传输层：建立端口到端口的通信，TCP或UDP传输数据</p> <p>网络层：建立主机到主机的通信，将数据传送到目标地址   IP</p> <p>数据链路层：物理层面上的通信传输 ARP协议</p> <p>物理层：负责0,1比特流与电压高低，光的闪灭之间的互换</p> <p>TCP/IP模型四层架构从下到上分别是链路层，网络层，传输层，应用层
<img src="https://img-blog.csdnimg.cn/20191015164008520.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JveWFhYm95,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p> <p>基于TCP的应用层协议：HTTP、FTP、SMTP、TELNET、SSH</p> <p>基于UDP的应用层协议：DNS、TFTP（简单文件传输协议）、SNMP：简单网络管理协议</p> <h3 id="window-onload-和-domcontentloaded-的区别"><a href="#window-onload-和-domcontentloaded-的区别" class="header-anchor">#</a> window.onload 和 DOMContentLoaded 的区别</h3> <p>DOMContentLoaded：仅当DOM加载完成，不包括样式表，图片，flash</p> <p>window.onload：页面完全加载触发，样式表，脚本，图片，flash都已经加载完成了。</p> <h3 id="请介绍下fetch发送2次请求的原因"><a href="#请介绍下fetch发送2次请求的原因" class="header-anchor">#</a> 请介绍下fetch发送2次请求的原因</h3> <p>用fetch的post请求的时候，导致fetch第一次发送了一个Options请求，询问服务器是否支持自定义的请求头，如果服务器支持，则在第二次中发送真正的请求。</p> <h3 id="浏览器中的常驻线程"><a href="#浏览器中的常驻线程" class="header-anchor">#</a> 浏览器中的常驻线程</h3> <p>GUI渲染线程  (页面重绘回流时执行，当JS引擎执行时被挂起)</p> <p>js引擎线程</p> <p>定时触发器线程</p> <p>事件触发线程</p> <p>异步http请求线程</p> <p>3D变换<code>translate3d</code>，<code>transform: translateZ(0)</code> 来开启硬件加速 。</p> <h3 id="网站的登录态是如何保持的，一个完整的登录流程是怎样实现的？"><a href="#网站的登录态是如何保持的，一个完整的登录流程是怎样实现的？" class="header-anchor">#</a> 网站的登录态是如何保持的，一个完整的登录流程是怎样实现的？</h3> <p>通过cookies来保持的，cookie面面存储token，每次请求到后端服务器都会带上token。从而验证用户是否登录。
输入用户、密码—&gt;点击登录，发送到服务端—&gt;服务端验证密码，生成token—&gt;写入到cookies，返回成功</p> <h3 id="cdn原理"><a href="#cdn原理" class="header-anchor">#</a> CDN原理</h3> <p>由于用户访问源站业务有性能瓶颈，通过cdn技术<strong>把源站的内容缓存到多个节点</strong>。用户向源站域名发起请求时，请求会被调度至<strong>最接近用户的服务节点</strong>，直接由服务节点直接快速响应，有效降低用户访问延迟，提升可用性。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/vuepress-test/front/DOM.html" class="prev">
        DOM
      </a></span> <span class="next"><a href="/vuepress-test/front/Vue.html">
        Vue
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/vuepress-test/assets/js/app.a9af0fa8.js" defer></script><script src="/vuepress-test/assets/js/2.f1d8a5fb.js" defer></script><script src="/vuepress-test/assets/js/9.ad2abf9c.js" defer></script>
  </body>
</html>
