<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>原生JS | 前端知识图谱</title>
    <meta name="generator" content="VuePress 1.5.0">
    <link rel="icon" href="/vuepress-test/a.jpg">
    <meta name="description" content="">
    <link rel="preload" href="/vuepress-test/assets/css/0.styles.3a07e25f.css" as="style"><link rel="preload" href="/vuepress-test/assets/js/app.a9af0fa8.js" as="script"><link rel="preload" href="/vuepress-test/assets/js/2.f1d8a5fb.js" as="script"><link rel="preload" href="/vuepress-test/assets/js/14.b4fced57.js" as="script"><link rel="prefetch" href="/vuepress-test/assets/js/10.4c45adf6.js"><link rel="prefetch" href="/vuepress-test/assets/js/11.c08eee5b.js"><link rel="prefetch" href="/vuepress-test/assets/js/12.c4bf0acf.js"><link rel="prefetch" href="/vuepress-test/assets/js/13.91b14ed5.js"><link rel="prefetch" href="/vuepress-test/assets/js/15.8d5cbeb0.js"><link rel="prefetch" href="/vuepress-test/assets/js/16.e9588432.js"><link rel="prefetch" href="/vuepress-test/assets/js/17.7217ca64.js"><link rel="prefetch" href="/vuepress-test/assets/js/18.91581d45.js"><link rel="prefetch" href="/vuepress-test/assets/js/3.e69ec39e.js"><link rel="prefetch" href="/vuepress-test/assets/js/4.22a09208.js"><link rel="prefetch" href="/vuepress-test/assets/js/5.37e26158.js"><link rel="prefetch" href="/vuepress-test/assets/js/6.3bcb7bf4.js"><link rel="prefetch" href="/vuepress-test/assets/js/7.284c6193.js"><link rel="prefetch" href="/vuepress-test/assets/js/8.d33bf6d7.js"><link rel="prefetch" href="/vuepress-test/assets/js/9.ad2abf9c.js">
    <link rel="stylesheet" href="/vuepress-test/assets/css/0.styles.3a07e25f.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/vuepress-test/" class="home-link router-link-active"><img src="/vuepress-test/a.jpg" alt="前端知识图谱" class="logo"> <span class="site-name can-hide">前端知识图谱</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/vuepress-test/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="https://github.com/shanfeng606" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="http://www.shanfeng606.work" target="_blank" rel="noopener noreferrer" class="nav-link external">
  主博客
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/vuepress-test/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="https://github.com/shanfeng606" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="http://www.shanfeng606.work" target="_blank" rel="noopener noreferrer" class="nav-link external">
  主博客
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/vuepress-test/front/HTML.html" class="sidebar-link">HTML</a></li><li><a href="/vuepress-test/front/CSS.html" class="sidebar-link">CSS</a></li><li><a href="/vuepress-test/front/原生JS.html" class="active sidebar-link">原生JS</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vuepress-test/front/原生JS.html#原生js" class="sidebar-link">原生JS</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vuepress-test/front/原生JS.html#es6-语法知道哪些，分别怎么用" class="sidebar-link">ES6 语法知道哪些，分别怎么用</a></li><li class="sidebar-sub-header"><a href="/vuepress-test/front/原生JS.html#es6中数组的新方法" class="sidebar-link">ES6中数组的新方法</a></li><li class="sidebar-sub-header"><a href="/vuepress-test/front/原生JS.html#var、let-及-const-区别（相当于变量提升题目）⭐" class="sidebar-link">var、let 及 const 区别（相当于变量提升题目）⭐</a></li><li class="sidebar-sub-header"><a href="/vuepress-test/front/原生JS.html#为什么0-1-0-2！-0-3" class="sidebar-link">为什么0.1+0.2！==0.3</a></li><li class="sidebar-sub-header"><a href="/vuepress-test/front/原生JS.html#与-的区别" class="sidebar-link">==与===的区别</a></li><li class="sidebar-sub-header"><a href="/vuepress-test/front/原生JS.html#null与undefined区别" class="sidebar-link">null与undefined区别</a></li><li class="sidebar-sub-header"><a href="/vuepress-test/front/原生JS.html#map、weakmap、set、weakset" class="sidebar-link">Map、WeakMap、Set、WeakSet</a></li><li class="sidebar-sub-header"><a href="/vuepress-test/front/原生JS.html#javascript-中-map-和-object-的区别" class="sidebar-link">JavaScript 中 Map 和 Object 的区别</a></li><li class="sidebar-sub-header"><a href="/vuepress-test/front/原生JS.html#javascript数组的迭代方法map-filter。。。" class="sidebar-link">JavaScript数组的迭代方法map,filter。。。</a></li><li class="sidebar-sub-header"><a href="/vuepress-test/front/原生JS.html#js的数据类型及存放位置" class="sidebar-link">JS的数据类型及存放位置</a></li><li class="sidebar-sub-header"><a href="/vuepress-test/front/原生JS.html#javascript中的几个假值" class="sidebar-link">javascript中的几个假值</a></li><li class="sidebar-sub-header"><a href="/vuepress-test/front/原生JS.html#基本类型跟引用类型的区别" class="sidebar-link">基本类型跟引用类型的区别</a></li><li class="sidebar-sub-header"><a href="/vuepress-test/front/原生JS.html#判断数据类型" class="sidebar-link">判断数据类型</a></li><li class="sidebar-sub-header"><a href="/vuepress-test/front/原生JS.html#如何理解js中基本数据类型的值不可变" class="sidebar-link">如何理解js中基本数据类型的值不可变</a></li><li class="sidebar-sub-header"><a href="/vuepress-test/front/原生JS.html#javascript对象的几种创建方式" class="sidebar-link">javascript对象的几种创建方式</a></li><li class="sidebar-sub-header"><a href="/vuepress-test/front/原生JS.html#什么是原型，什么是原型链⭐" class="sidebar-link">什么是原型，什么是原型链⭐</a></li><li class="sidebar-sub-header"><a href="/vuepress-test/front/原生JS.html#同步异步的区别" class="sidebar-link">同步异步的区别</a></li><li class="sidebar-sub-header"><a href="/vuepress-test/front/原生JS.html#异步编程方案" class="sidebar-link">异步编程方案</a></li><li class="sidebar-sub-header"><a href="/vuepress-test/front/原生JS.html#async-await-怎么用，如何捕获异常？" class="sidebar-link">async/await 怎么用，如何捕获异常？</a></li><li class="sidebar-sub-header"><a href="/vuepress-test/front/原生JS.html#promise原理" class="sidebar-link">Promise原理</a></li><li class="sidebar-sub-header"><a href="/vuepress-test/front/原生JS.html#proxy的理解" class="sidebar-link">proxy的理解</a></li><li class="sidebar-sub-header"><a href="/vuepress-test/front/原生JS.html#这段代码里的-this-是什么？⭐" class="sidebar-link">这段代码里的 this 是什么？⭐</a></li><li class="sidebar-sub-header"><a href="/vuepress-test/front/原生JS.html#this指向的形式4种" class="sidebar-link">this指向的形式4种</a></li><li class="sidebar-sub-header"><a href="/vuepress-test/front/原生JS.html#bind、call、apply的区别" class="sidebar-link">bind、call、apply的区别</a></li><li class="sidebar-sub-header"><a href="/vuepress-test/front/原生JS.html#闭包-立即执行函数是什么？⭐" class="sidebar-link">闭包/立即执行函数是什么？⭐</a></li><li class="sidebar-sub-header"><a href="/vuepress-test/front/原生JS.html#如何用正则实现-trim-？" class="sidebar-link">如何用正则实现 trim()？</a></li><li class="sidebar-sub-header"><a href="/vuepress-test/front/原生JS.html#垃圾回收机制⭐-有待补充" class="sidebar-link">垃圾回收机制⭐(有待补充)</a></li><li class="sidebar-sub-header"><a href="/vuepress-test/front/原生JS.html#如何捕获js中的异常" class="sidebar-link">如何捕获JS中的异常</a></li><li class="sidebar-sub-header"><a href="/vuepress-test/front/原生JS.html#requestanimationframe的优势是什么？" class="sidebar-link">requestAnimationFrame的优势是什么？</a></li><li class="sidebar-sub-header"><a href="/vuepress-test/front/原生JS.html#js为啥是单线程的" class="sidebar-link">JS为啥是单线程的</a></li><li class="sidebar-sub-header"><a href="/vuepress-test/front/原生JS.html#说一下事件循环-event-loop-？" class="sidebar-link">说一下事件循环(Event Loop)？</a></li><li class="sidebar-sub-header"><a href="/vuepress-test/front/原生JS.html#类数组与数组的区别" class="sidebar-link">类数组与数组的区别</a></li><li class="sidebar-sub-header"><a href="/vuepress-test/front/原生JS.html#箭头函数和普通函数的区别" class="sidebar-link">箭头函数和普通函数的区别</a></li><li class="sidebar-sub-header"><a href="/vuepress-test/front/原生JS.html#如何判断两个数组相同" class="sidebar-link">如何判断两个数组相同</a></li><li class="sidebar-sub-header"><a href="/vuepress-test/front/原生JS.html#如何判断两个对象相同" class="sidebar-link">如何判断两个对象相同</a></li><li class="sidebar-sub-header"><a href="/vuepress-test/front/原生JS.html#判断一个数组" class="sidebar-link">判断一个数组</a></li><li class="sidebar-sub-header"><a href="/vuepress-test/front/原生JS.html#js中遍历对象和遍历数组的方法" class="sidebar-link">js中遍历对象和遍历数组的方法</a></li><li class="sidebar-sub-header"><a href="/vuepress-test/front/原生JS.html#实现图片懒加载的原理" class="sidebar-link">实现图片懒加载的原理</a></li><li class="sidebar-sub-header"><a href="/vuepress-test/front/原生JS.html#js输出信息的5种方式" class="sidebar-link">JS输出信息的5种方式</a></li><li class="sidebar-sub-header"><a href="/vuepress-test/front/原生JS.html#实现数组相加的方法" class="sidebar-link">实现数组相加的方法</a></li></ul></li></ul></li><li><a href="/vuepress-test/front/DOM.html" class="sidebar-link">DOM</a></li><li><a href="/vuepress-test/front/HTTP+浏览器.html" class="sidebar-link">HTTP/浏览器</a></li><li><a href="/vuepress-test/front/Vue.html" class="sidebar-link">Vue</a></li><li><a href="/vuepress-test/front/Webpack.html" class="sidebar-link">Webpack</a></li><li><a href="/vuepress-test/front/安全.html" class="sidebar-link">安全</a></li><li><a href="/vuepress-test/front/编程题.html" class="sidebar-link">编程题</a></li><li><a href="/vuepress-test/front/手写题.html" class="sidebar-link">手写题</a></li><li><a href="/vuepress-test/front/算法.html" class="sidebar-link">算法母题</a></li><li><a href="/vuepress-test/front/其他.html" class="sidebar-link">其他</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="原生js"><a href="#原生js" class="header-anchor">#</a> 原生JS</h2> <h3 id="es6-语法知道哪些，分别怎么用"><a href="#es6-语法知道哪些，分别怎么用" class="header-anchor">#</a> ES6 语法知道哪些，分别怎么用</h3> <p>https://fangyinghang.com/es-6-tutorials/</p> <p>let const 展开运算符 解构赋值 模块导入导出 class继承 promise symbol,set数据类型</p> <h3 id="es6中数组的新方法"><a href="#es6中数组的新方法" class="header-anchor">#</a> ES6中数组的新方法</h3> <p>1、扩展运算符 ...<br>
2、Array.from()<br>
3、Array,of()    <code>Array.of</code>方法用于将一组值，转换为数组。     Array.of(3, 11, 8) // [3,11,8]<br>
4、fill() 填充数组<br>
5、find() 和 findindex()</p> <div class="language- extra-class"><pre class="language-text"><code>[1, 4, -5, 10].find((n) =&gt; n &lt; 0)
// -5
</code></pre></div><p>6、includes()   返回一个布尔值，表示某个数组是否包含给定的值</p> <p>7、entries()  /keys()  /values()</p> <h3 id="var、let-及-const-区别（相当于变量提升题目）⭐"><a href="#var、let-及-const-区别（相当于变量提升题目）⭐" class="header-anchor">#</a> var、let 及 const 区别（相当于变量提升题目）⭐</h3> <p>以下需要记牢（五点）：</p> <ul><li><p>var声明的变量会挂载在window上，而let和const声明的变量不会</p></li> <li><p>var声明变量存在变量提升，let和const不存在变量提升</p> <p><strong>块级作用域+不允许重复声明+暂存死区</strong></p></li> <li><p>let和const声明形成块作用域，而var不存在此作用域</p></li> <li><p>同一作用域下let和const不能声明同名变量，而var可以</p></li> <li><p>let、const存在暂存死区</p></li></ul> <p>const 定义的基本数据类型的变量不能修改，但引用类型可以修改指向的内容，但不能修改指针指向</p> <p>JavaScript 中，函数及变量的声明都将被提升到函数的最顶部。</p> <p>JavaScript 中，变量可以在使用后声明，也就是变量可以先使用再声明。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">// undefined</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span>
</code></pre></div><ul><li>函数提升优先于变量提升，函数提升会把整个函数挪到作用域顶部，变量提升只会把声明挪到作用域顶部</li> <li><code>var</code> 存在提升，我们能在声明之前使用。<code>let</code>、<code>const</code> 因为暂时性死区的原因，不能在声明前使用</li> <li><code>var</code> 在全局作用域下声明变量会导致变量挂载在 <code>window</code> 上，其他两者不会</li> <li><code>let</code> 和 <code>const</code> 作用基本一致，但是后者声明的变量不能再次赋值</li></ul> <p>为什么要变量提升</p> <p>1、提高性能，让函数可以在执行时预先为变量分配栈空间</p> <p>在JS代码执行之前，会进行语法检查和预编译，并且这一操作只进行一次。这么做就是为了提高性能，如果没有这一步，那么每次执行代码前都必须重新解析一遍该变量（函数），而这是没有必要的，因为变量（函数）的代码并不会改变，解析一遍就够了。</p> <p>2、声明提升还可以提高JS代码的容错性，使一些不规范的代码也可以正常执行</p> <p>为什么要使用let</p> <ul><li>let 不会在全局对象中新建一个属性</li> <li>在处理构造函数的时候，可以通过<code>let</code>声明而不是闭包来创建一个或多个私有成员。</li> <li>更好的报错机制，在同一个函数或块作用域中重复声明同一个变量会引起<code>SyntaxError</code></li></ul> <h3 id="为什么0-1-0-2！-0-3"><a href="#为什么0-1-0-2！-0-3" class="header-anchor">#</a> 为什么0.1+0.2！==0.3</h3> <p>因为 0.1 和 0.2 被转成二进制后会无限循环，由于JS中位数的限制多余的位数会被截掉，就出现了精度损失。
解决方法：<strong>toFixed()，toFixed() 方法可把 Number 四舍五入为指定小数位数的数字。</strong></p> <h3 id="与-的区别"><a href="#与-的区别" class="header-anchor">#</a> ==与===的区别</h3> <p>&quot;==&quot; 就代表会先把两端的变量试图转换成相同类型，然后再比较；</p> <p>&quot;===&quot; 就代表会直接去比较类型是否相同，如果类型相同则继续比较值是否相同。</p> <p>==操作符的强制类型转换规则，看看就好</p> <div class="language- extra-class"><pre class="language-text"><code>（1）字符串和数字之间的相等比较，将字符串转换为数字之后再进行比较。

（2）其他类型和布尔类型之间的相等比较，先将布尔值转换为数字后，再应用其他规则进行比较。

（3）null 和 undefined 之间的相等比较，结果为真。其他值和它们进行比较都返回假值。

（4）对象和非对象之间的相等比较，对象先调用 ToPrimitive 抽象操作后，再进行比较。

（5）如果一个操作值为 NaN ，则相等比较返回 false（ NaN 本身也不等于 NaN ）。

（6）如果两个操作值都是对象，则比较它们是不是指向同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回 true，否则，返回 false。
</code></pre></div><h3 id="null与undefined区别"><a href="#null与undefined区别" class="header-anchor">#</a> null与undefined区别</h3> <p>**null表示&quot;没有对象&quot;，即该处不应该有值。**典型用法是：</p> <div class="language- extra-class"><pre class="language-text"><code>（1） 作为函数的参数，表示该函数的参数不是对象。

（2） 作为对象原型链的终点。
</code></pre></div><p>**undefined表示&quot;缺少值&quot;，就是此处应该有一个值，但是还没有定义。**典型用法是：</p> <div class="language- extra-class"><pre class="language-text"><code>（1）变量被声明了，但没有赋值时，就等于undefined。

（2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。

（3）对象没有赋值的属性，该属性的值为undefined。

（4）函数没有返回值时，默认返回undefined。
</code></pre></div><p>摘自阮一峰：</p> <p>https://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html</p> <p>undefined !== null  //true
undefined == null  //true</p> <h3 id="map、weakmap、set、weakset"><a href="#map、weakmap、set、weakset" class="header-anchor">#</a> Map、WeakMap、Set、WeakSet</h3> <p><strong>Set</strong></p> <ul><li><p>成员不能重复，成员可以使任意类型的值</p></li> <li><p>只有健值，没有健名，有点类似数组。</p></li> <li><p>可以遍历，方法有add, delete，has</p></li></ul> <p><strong>WeakSet</strong></p> <ul><li><p>成员只能是对象</p></li> <li><p>成员都是弱引用，垃圾回收机制不考虑WeakSet对该对象的引用</p></li> <li><p>不能遍历，方法有add, delete,has</p></li></ul> <p><strong>Map</strong></p> <ul><li><p>本质上是健值对的集合，类似集合，可以接受任何类型的值作为键名</p></li> <li><p>可以遍历，方法很多，可以干跟各种数据格式转换</p></li></ul> <p><strong>WeakMap</strong></p> <ul><li><p>只接受对象作为健名（null除外），不接受其他类型的值作为健名</p></li> <li><p>健名所指向的对象，不计入垃圾回收机制</p></li> <li><p>不能遍历，方法同get,set,has,delete</p></li></ul> <h3 id="javascript-中-map-和-object-的区别"><a href="#javascript-中-map-和-object-的区别" class="header-anchor">#</a> JavaScript 中 Map 和 Object 的区别</h3> <p>1：Object对象有原型， 也就是说他有默认的key值在对象上面， 除非我们使用Object.create(null)创建一个没有原型的对象
2：在Object对象中， 只能把String和Symbol作为key值， 但是在Map中，key值可以是任何基本类型的值或者对象
3：通过Map中的size属性， 可以很方便地获取到Map长度， 要获取Object的长度， 你只能用别的方法了</p> <p>https://blog.csdn.net/liangchuannan/article/details/70053038</p> <h3 id="javascript数组的迭代方法map-filter。。。"><a href="#javascript数组的迭代方法map-filter。。。" class="header-anchor">#</a> JavaScript数组的迭代方法map,filter。。。</h3> <p>map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。</p> <p>forEach() 方法对数组的每个元素执行一次提供的函数。</p> <p>some() 和 every() 方法不会改变原始数组。</p> <h3 id="js的数据类型及存放位置"><a href="#js的数据类型及存放位置" class="header-anchor">#</a> JS的数据类型及存放位置</h3> <ul><li><p><strong>Number</strong></p></li> <li><p><strong>string</strong></p></li> <li><p><strong>Boolean</strong></p></li> <li><p><strong>Null</strong></p></li> <li><p><strong>Undefined</strong></p></li> <li><p><strong>Symbol</strong>（ES6中新引入的新类型---可以用来创建匿名的对象属性，代表创建后独一无二且不可变的数据类型，它的出现我认为主要是为了解决可能出现的全局变量冲突的问题。）</p></li> <li><p><strong>BigInt</strong>（它可以表示任意精度格式的整数）</p> <p>原始类型存储的都是值，是没有函数可以调用的，<code>typeof null</code>会输出<code>object</code>，是JS存在的一个bug</p></li></ul> <p>（一共有8种数据类型，其中7种是原始类型）</p> <p>栈：原始数据类型（Undefined、Null、Boolean、Number、String）</p> <p>堆：引用数据类型（对象、数组和函数）
string：基本包装类型</p> <h3 id="javascript中的几个假值"><a href="#javascript中的几个假值" class="header-anchor">#</a> javascript中的几个假值</h3> <p><strong>false,null,undefined,0,”(空字符串),NaN</strong></p> <h3 id="基本类型跟引用类型的区别"><a href="#基本类型跟引用类型的区别" class="header-anchor">#</a> 基本类型跟引用类型的区别</h3> <p>**声明变量时不同的内存分配：**一个在栈，一个堆</p> <p><strong>不同的内存分配机制也带来了不同的访问机制</strong>：原始类型可以直接访问，引用类型按引用访问</p> <p><strong>复制变量时的不同</strong>：基本类型复制出独立数据，引用类型复制的一个指针</p> <h3 id="判断数据类型"><a href="#判断数据类型" class="header-anchor">#</a> 判断数据类型</h3> <p><strong>typeof（原始数据类型）</strong></p> <p>它返回表示数据类型的<strong>字符串</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">typeof</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>                              <span class="token comment">//number</span>
<span class="token keyword">typeof</span><span class="token punctuation">(</span><span class="token string">&quot;1&quot;</span><span class="token punctuation">)</span>                            <span class="token comment">//string</span>
<span class="token keyword">typeof</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>                           <span class="token comment">//boolean</span>
<span class="token keyword">typeof</span><span class="token punctuation">(</span><span class="token keyword">undefined</span><span class="token punctuation">)</span>                      <span class="token comment">//undefined</span>
<span class="token keyword">typeof</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>                           <span class="token comment">//object</span>
</code></pre></div><p>**注释：**您也许会问，为什么 typeof 运算符对于 null 值会返回 &quot;object&quot;。这实际上是 JavaScript 最初实现中的一个错误，然后被 ECMAScript 沿用了。现在，null 被认为是对象的占位符，从而解释了这一矛盾，但从技术上来说，它仍然是原始值。</p> <p><strong>instanceof（引用类型）</strong></p> <p>原理 因为A instanceof B 可以判断A是不是B的实例，返回一个<strong>布尔值</strong>，由构造类型判断出数据类型</p> <div class="language-js extra-class"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr <span class="token keyword">instanceof</span> <span class="token class-name">Array</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>date <span class="token keyword">instanceof</span> <span class="token class-name">Date</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>fn <span class="token keyword">instanceof</span> <span class="token class-name">Function</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
<span class="token comment">//注意： instanceof 后面一定要是对象类型，大小写不能写错，该方法试用一些条件选择或分支</span>
</code></pre></div><p><strong>缺点</strong></p> <p>instanceof检测的是原型，不能完全精确的判断object类的具体数据类型，比如：</p> <div class="language- extra-class"><pre class="language-text"><code>console.log([] instanceof Object)   //true
console.log([] instanceof Array)    //true
</code></pre></div><p><strong>使用<code>Object.prototype.toString.call()</code>来判断值的类型</strong></p> <p>可以<strong>通用</strong>的来判断原始数据类型和引用数据类型</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">{</span>name<span class="token operator">:</span><span class="token string">'Jack'</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment">// [object Object]</span>
<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment">// [object Function]</span>
<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token regex">/name/</span><span class="token punctuation">)</span> <span class="token comment">// [object RegExp]</span>
</code></pre></div><p>而对于基本类型：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">'abc'</span><span class="token punctuation">)</span> <span class="token comment">// [object String]</span>
<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">)</span> <span class="token comment">// [object Number]</span>
<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token comment">// [object Boolean]</span>
</code></pre></div><p>基本类型值是没有构造函数的，为什么也能返回构造函数名呢？这是因为在<code>toString</code>被调用时 JavaScript 将基本类型值转换成了包装类型。</p> <p>而对于<code>null</code>和<code>undefined</code>：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span> <span class="token keyword">null</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>			<span class="token comment">// &quot;[object Null]&quot;</span>
<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span> <span class="token keyword">undefined</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// &quot;[object Undefined]&quot;</span>
</code></pre></div><p>虽然 JavaScript 中没有<code>Null()</code>和<code>Undefined</code>构造器，但是 JavaScript 也为我们处理这这两种情况。<br> <strong>原理</strong></p> <p><strong>所有类在继承Object的时候，改写了toString()方法。</strong> Object原型上的方法是可以输出数据类型的。因此我们想判断数据类型时，也只能使用原始方法。继而有了此方法：<code>Object.prototype.toString.call(obj)</code></p> <h3 id="如何理解js中基本数据类型的值不可变"><a href="#如何理解js中基本数据类型的值不可变" class="header-anchor">#</a> 如何理解js中基本数据类型的值不可变</h3> <p><strong>在 JavaScript 中，字符串的值是不可变的，这意味着一旦字符串被创建就不能被改变</strong></p> <p>栈创建的时候，大小是确定的</p> <p>而堆的大小是不确定的，需要的话可以不断增加</p> <h3 id="javascript对象的几种创建方式"><a href="#javascript对象的几种创建方式" class="header-anchor">#</a> javascript对象的几种创建方式</h3> <p>1、字面量方式  {}</p> <p>2、调用系统的构造函数 new Object()</p> <p>3、Object.create()也可以用于创建对象</p> <p>4、自定义构造函数的方式</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Student</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span>age<span class="token punctuation">,</span><span class="token constant">ID</span><span class="token punctuation">,</span>sex</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token operator">=</span>name<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token operator">=</span>age<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token constant">ID</span><span class="token operator">=</span><span class="token constant">ID</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>sex<span class="token operator">=</span>sex<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">sayHi</span><span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;您好！&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
        <span class="token comment">//创建对象---&gt;实例化一个对象，同时对属性进行初始化。</span>
        <span class="token comment">//    1.开辟空间存储对象</span>
        <span class="token comment">//    2.把this设置为当前的对象</span>
        <span class="token comment">//    3.设置属性和方法的值</span>
        <span class="token comment">//    4.把this对象返回</span>
        <span class="token keyword">var</span> stu3<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">&quot;小天&quot;</span><span class="token punctuation">,</span><span class="token number">18</span><span class="token punctuation">,</span><span class="token number">20181113</span><span class="token punctuation">,</span><span class="token string">&quot;男&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>5、工厂模式创建对象</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">student</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span>age<span class="token punctuation">,</span><span class="token constant">ID</span><span class="token punctuation">,</span>sex</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    obj<span class="token punctuation">.</span>name<span class="token operator">=</span>name<span class="token punctuation">;</span>
    obj<span class="token punctuation">.</span>age<span class="token operator">=</span>age<span class="token punctuation">;</span>
    obj<span class="token punctuation">.</span><span class="token constant">ID</span><span class="token operator">=</span><span class="token constant">ID</span><span class="token punctuation">;</span>
    obj<span class="token punctuation">.</span>sex<span class="token operator">=</span>sex<span class="token punctuation">;</span>
    obj<span class="token punctuation">.</span><span class="token function-variable function">sayHi</span><span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;您好！&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> obj<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> stu4<span class="token operator">=</span><span class="token function">student</span><span class="token punctuation">(</span><span class="token string">&quot;小菊&quot;</span><span class="token punctuation">,</span><span class="token number">21</span><span class="token punctuation">,</span><span class="token number">20181114</span><span class="token punctuation">,</span><span class="token string">&quot;女&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>工厂模式和自定义构造函数创建对象的区别：</p> <p><img src="https://img-blog.csdn.net/20180622113822343?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NsZWVwd2Fsa2VyXzE5OTI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p> <h3 id="什么是原型，什么是原型链⭐"><a href="#什么是原型，什么是原型链⭐" class="header-anchor">#</a> 什么是原型，什么是原型链⭐</h3> <p><strong>原型</strong></p> <p>我们创建的每个函数都有一个 <code>prototype(原型)</code> 属性，这个属性是一个指针，指向一个原型对象。其实原型对象就只是个普通对象，里面存放着所有实例对象需要共享的属性和方法！</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span>age</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>	<span class="token comment">//不需要共享的属性和方法放在构造函数里</span>
<span class="token punctuation">}</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>sex <span class="token operator">=</span> <span class="token string">'female'</span><span class="token punctuation">;</span>    <span class="token comment">//prototype属性，存放所有实例共享的属性与方法</span>

<span class="token keyword">var</span> person1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">&quot;Summer&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> person2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">&quot;Lily&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person1<span class="token punctuation">.</span>sex<span class="token punctuation">)</span>      <span class="token comment">// female</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person2<span class="token punctuation">.</span>sex<span class="token punctuation">)</span>      <span class="token comment">// female</span>

<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>sex <span class="token operator">=</span> <span class="token string">'male'</span><span class="token punctuation">;</span>      <span class="token comment">//修改prototype属性会影响它的所有实例的sex的值！！</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person1<span class="token punctuation">.</span>sex<span class="token punctuation">)</span>      <span class="token comment">// male</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person2<span class="token punctuation">.</span>sex<span class="token punctuation">)</span>      <span class="token comment">// male</span>
</code></pre></div><p><strong>原型链</strong></p> <p>当访问一个对象的某个属性时，会先在这个对象本身属性上查找，如果没有找到，则会去它的__proto__隐式原型上查找，即它的构造函数的prototype，如果还没有找到就会再在构造函数的prototype的__proto__中查找，这样一层一层向上查找就会形成一个链式结构，我们称为原型链。
<img src="https://cdn.nlark.com/yuque/0/2018/png/199663/1544807307596-1e74bf82-9587-458b-bcff-62dfd57b0c87.png" alt="img">{:height=&quot;50%&quot; width=&quot;50%&quot;}</p> <h3 id="同步异步的区别"><a href="#同步异步的区别" class="header-anchor">#</a> 同步异步的区别</h3> <p><strong>异步</strong>不会阻塞代码的执行，使用场景：网络请求&amp;定时任务</p> <p><strong>同步</strong>会阻塞代码执行</p> <p><strong>同步异步</strong></p> <p>首先来解释同步和异步的概念，这两个概念与消息的通知机制有关。也就是同步与异步主要是从<strong>消息通知机制</strong>角度来说的。</p> <p>所谓同步就是一个任务的完成需要依赖另外一个任务时，只有等待被依赖的任务完成后，依赖的任务才能算完成，这是一种可靠的任务序列。要么成功都成功，失败都失败，两个任务的状态可以保持一致。</p> <p>所谓异步是不需要等待被依赖的任务完成，只是通知被依赖的任务要完成什么工作，依赖的任务也立即执行，只要自己完成了整个任务就算完成了。至于被依赖的任务最终是否真正完成，依赖它的任务无法确定，所以它是不可靠的任务序列。</p> <p><strong>阻塞非阻塞</strong></p> <p>阻塞和非阻塞这两个概念与<strong>程序（线程）等待消息通知(无所谓同步或者异步)时的状态</strong>有关。也就是说阻塞与非阻塞主要是程序（线程）等待消息通知时的状态角度来说的。</p> <p>阻塞调用是指调用结果返回之前，当前线程会被挂起，一直处于等待消息通知，不能够执行其他业务。函数只有在得到结果之后才会返回。</p> <h3 id="异步编程方案"><a href="#异步编程方案" class="header-anchor">#</a> 异步编程方案</h3> <p>1.JS 异步编程进化史：callback -&gt; promise -&gt; generator(*|yield) -&gt; async + await</p> <p>2.<strong>async/await 函数的实现</strong>，<code>async</code>函数就是将 Generator 函数的星号（<code>*</code>）替换成<code>async</code>，将<code>yield</code>替换成<code>await</code>，仅此而已。</p> <ul><li><p>内置执行器，不需要像generate函数，需要调用next方法</p></li> <li><p>更好的语义，<code>async</code>表示函数里有异步操作，<code>await</code>表示紧跟在后面的表达式需要等待结果</p></li> <li><p>更广的适用性。<code>async</code>函数的<code>await</code>命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即 resolved 的 Promise 对象）。</p></li> <li><p>返回值是 Promise。你可以用<code>then</code>方法指定下一步的操作。</p></li></ul> <p>3.async/await可以说是异步终极解决方案了。</p> <h4 id="promise对象"><a href="#promise对象" class="header-anchor">#</a> promise对象</h4> <ol><li>作用： 解决异步回调嵌套问题(回调地狱)，将异步的流程用同步的形式表达出来</li> <li>思想：
<ul><li>给promise设置的三种状态： pending, fullfilled, rejected</li> <li>通过异步任务的执行结果动态的去修改promise的状态</li> <li>promise状态的改变可以去then方法中的成功或者失败的回调</li> <li>可以通过resolve，reject调用的时候将数据传递给成功或者失败的回调</li></ul></li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">//初始化promise的状态为pending----&gt;初始化状态</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'1111'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//同步执行</span>
    <span class="token comment">//启动异步任务</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'3333'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//resolve('atguigu.com');//修改promise的状态pending----&gt;fullfilled（成功状态）</span>
        <span class="token function">reject</span><span class="token punctuation">(</span><span class="token string">'xxxx'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//修改promise的状态pending-----&gt;rejected(失败状态)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'成功了。。。'</span> <span class="token operator">+</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">error</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'失败了'</span> <span class="token operator">+</span> error<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'2222'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="generator函数"><a href="#generator函数" class="header-anchor">#</a> Generator函数</h4> <ol><li>概念：
1、ES6提供的解决异步编程的方案之一
2、Generator函数是一个状态机，内部封装了不同状态的数据，
3、用来生成遍历器对象
4、可暂停函数<code>(惰性求值)</code>,<code>yield可暂停</code>，<code>next方法可启动</code>。每次返回的是yield后的表达式结果</li> <li>特点：
1、function 与函数名之间有一个星号
2、内部用yield表达式来定义不同的状态
例如：
function* generatorExample(){
let result = yield ‘hello’; // 状态值为hello
yield ‘generator’; // 状态值为generator
}
3、generator函数返回的是指针对象(iterator)，而不会执行函数内部逻辑
4、调用next方法函数内部逻辑开始执行，遇到yield表达式停止，返回{value: yield后的表达式结果/undefined, done: false/true}
5、再次调用next方法会从上一次停止时的yield处开始，直到最后
6、yield语句返回结果通常为undefined， 当调用next方法时传参内容会作为启动时yield语句的返回值。 （此方法过于繁琐不推荐使用）</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">myGenerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'开始'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> result<span class="token operator">=</span><span class="token keyword">yield</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//hello</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'暂停了'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">yield</span>  <span class="token string">'你好'</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'end'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token string">&quot;end&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> Mg<span class="token operator">=</span> <span class="token function">myGenerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Mg<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Mg<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token string">'hello'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//需调用next重新启动，并且可以传参。</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Mg<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="async函数"><a href="#async函数" class="header-anchor">#</a> async函数</h4> <ol><li>作用: 解决异步回调</li> <li>语法：</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">await</span> 异步操作<span class="token punctuation">;</span>
    <span class="token keyword">await</span> 异步操作；
<span class="token punctuation">}</span>
</code></pre></div><ol><li>通常和promise配合使用，</li> <li>async代表异步， await等待异步执行</li></ol> <ul><li>异步任务执行成功以后才会执行后续的代码返回的</li> <li>根据promise实例对象的状态决定的
注意点：awit返回值，async的返回值为Promise</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span>reject</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;我是promise&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">setTimeout</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;开始执行&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">await</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;执行完毕&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="async-await-怎么用，如何捕获异常？"><a href="#async-await-怎么用，如何捕获异常？" class="header-anchor">#</a> async/await 怎么用，如何捕获异常？</h3> <p><strong>async</strong></p> <p>ES2017 标准引入了 async 函数，使得异步操作变得更加方便。</p> <p>async 函数是什么？一句话，它就是 Generator 函数的语法糖。</p> <p><code>async</code>函数就是将 Generator 函数的星号（<code>*</code>）替换成<code>async</code>，将<code>yield</code>替换成<code>await</code>，仅此而已。</p> <p><strong>await</strong></p> <p>正常情况下，<code>await</code>命令后面是一个 <strong>Promise 对象</strong>，返回该对象的结果。如果不是 Promise 对象，就直接返回对应的值。</p> <p><code>await</code>命令只能用在<code>async</code>函数之中，如果用在普通函数，就会报错。</p> <p><code>await</code>命令后面的<code>Promise</code>对象，运行结果可能是<code>rejected</code>，所以最好把<code>await</code>命令放在<code>try...catch</code>代码块中。</p> <h3 id="promise原理"><a href="#promise原理" class="header-anchor">#</a> Promise原理</h3> <p>阮一峰ES6中的解释：</p> <p>Promise 是异步编程的一种解决方案，解决了回调地狱的问题</p> <p>所谓<code>Promise</code>，简单说就是一个容器，里面保存着某个未来才会结束的事件的结果（通常是一个异步操作）。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p> <p><strong>特点</strong></p> <ul><li>对象的状态不受外界影响。<code>Promise</code>对象代表一个异步操作，有三种状态：<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）和<code>rejected</code>（已失败）。</li> <li>一旦状态改变，就不会再变</li></ul> <p><strong>then</strong></p> <p>Promise 实例具有<code>then</code>方法，也就是说，<code>then</code>方法是定义在原型对象<code>Promise.prototype</code>上的。它的作用是为 Promise 实例添加状态改变时的回调函数。前面说过，<code>then</code>方法的第一个参数是<code>resolved</code>状态的回调函数，第二个参数（可选）是<code>rejected</code>状态的回调函数。</p> <p><code>then</code>方法返回的是一个新的<code>Promise</code>实例（注意，不是原来那个<code>Promise</code>实例）。因此可以采用<strong>链式写法</strong>，即<code>then</code>方法后面再调用另一个<code>then</code>方法。</p> <p>阮一峰原文 https://es6.ruanyifeng.com/#docs/promise</p> <h3 id="proxy的理解"><a href="#proxy的理解" class="header-anchor">#</a> proxy的理解</h3> <p>Proxy 可以理解成，在目标对象之前架设一层**“拦截”**，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。<br>
proxy代理，扩展（增强）对象的一些功能：比如Vue中拦截等</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//语法</span>
<span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span>handler<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> obj<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>被代理的对象，对代理的对象做什么操作<span class="token punctuation">)</span>
handler<span class="token operator">:</span><span class="token punctuation">{</span>
	<span class="token keyword">set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token comment">//设置的时候执行</span>
	<span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token comment">//获取的时候执行</span>
	<span class="token function">deleteProperty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token function">has</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token operator">...</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//实例</span>
<span class="token keyword">let</span> obj<span class="token operator">=</span><span class="token punctuation">{</span>
	name<span class="token operator">:</span><span class="token string">'aaa'</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> newObj<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span><span class="token punctuation">{</span>
	<span class="token keyword">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span>property<span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token keyword">return</span> target<span class="token punctuation">[</span>property<span class="token punctuation">]</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>newObj<span class="token punctuation">.</span>name<span class="token punctuation">)</span>
</code></pre></div><h3 id="这段代码里的-this-是什么？⭐"><a href="#这段代码里的-this-是什么？⭐" class="header-anchor">#</a> 这段代码里的 this 是什么？⭐</h3> <p>this的值是在<strong>函数执行时</strong>确定的</p> <ol><li>fn()    （比如setInterval()）
this =&gt; window/global</li> <li>obj.fn()
this =&gt; obj</li> <li>fn.call/apply/bind(xx)
this =&gt; xx</li> <li>new Fn()
this =&gt; 新的对象</li> <li>fn = ()=&gt; {}
this =&gt; 外面的 this</li></ol> <h3 id="this指向的形式4种"><a href="#this指向的形式4种" class="header-anchor">#</a> this指向的形式4种</h3> <p>a.如果是一般函数,this指向全局对象window</p> <p>b.在严格模式下&quot;use strict&quot;,为undefined</p> <p>c.对象的方法里调用,this指向调用该方法的对象</p> <p>d.构造函数里的this,指向创建出来的实例</p> <p>e.箭头函数，指向外面</p> <h3 id="bind、call、apply的区别"><a href="#bind、call、apply的区别" class="header-anchor">#</a> bind、call、apply的区别</h3> <p><code>call</code>和<code>apply</code>改变了函数的this上下文后便<strong>执行该函数</strong>，而<code>bind</code>则是<strong>返回</strong>改变了上下文后的一个<strong>函数</strong>。</p> <p>他们俩之间的差别在于参数的区别，<code>call</code>和<code>apply</code>的第一个参数都是要改变上下文的对象，而<code>call</code>从第二个参数开始以参数列表的形式展现，<code>apply</code>则是把参数放在一个数组里面作为它的第二个参数。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span>p1<span class="token punctuation">,</span>p2<span class="token punctuation">,</span>p3<span class="token punctuation">)</span>
<span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span>arguments<span class="token punctuation">)</span>
</code></pre></div><h3 id="闭包-立即执行函数是什么？⭐"><a href="#闭包-立即执行函数是什么？⭐" class="header-anchor">#</a> 闭包/立即执行函数是什么？⭐</h3> <p><strong>闭包的定义</strong>：其实很简单：函数 A 内部有一个函数 B，函数 B 可以访问到函数 A 中的变量，那么函数 B 就是闭包。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">//闭包隐藏数据，只提供API</span>
<span class="token keyword">function</span> <span class="token function">createCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">const</span> data<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">//闭包中的数据，被隐藏，不被外接访问</span>
    <span class="token keyword">return</span><span class="token punctuation">{</span>
        <span class="token function-variable function">set</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">key<span class="token punctuation">,</span>val</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            data<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token operator">=</span>val
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token function-variable function">get</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">key</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">return</span> data<span class="token punctuation">[</span>key<span class="token punctuation">]</span> 
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> c <span class="token operator">=</span> <span class="token function">createCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
c<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><p><strong>闭包的作用</strong>
1.可以在函数外调用闭包函数，访问到函数内的变量，可以用这种方法来创建私有变量
2.保护变量不被内存回收机制回收</p> <p><strong>闭包的缺点</strong>
闭包长期占用内存，内存消耗很大，可能导致内存泄露</p> <p><strong>立即执行函数</strong>就是</p> <ol><li>声明一个匿名函数</li> <li>马上调用这个匿名函数</li></ol> <p>只有一个作用：创建一个独立的作用域。</p> <h3 id="如何用正则实现-trim-？"><a href="#如何用正则实现-trim-？" class="header-anchor">#</a> 如何用正则实现 trim()？</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">trim</span><span class="token punctuation">(</span><span class="token parameter">string</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> string<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex">/^\s+|\s+$/g</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="垃圾回收机制⭐-有待补充"><a href="#垃圾回收机制⭐-有待补充" class="header-anchor">#</a> 垃圾回收机制⭐(有待补充)</h3> <p><strong>垃圾回收的意思可以理解为，将已经不需要的内存释放</strong>
一个主要的方法就是：找出用不到的对象，然后删除它</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//假设有一个对象a,占用了100m内存</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token comment">/*我占用了100M内存*/</span><span class="token punctuation">}</span>
a <span class="token operator">=</span> <span class="token keyword">null</span>  <span class="token comment">// 浏览器就会垃圾回收掉那100m内存 什么时候回收不确定</span>
</code></pre></div><p><strong>总结来说就是：把所有指向这块内存的变量全部置为<code>null</code></strong></p> <ol><li><p>什么是垃圾（没有被引用的是垃圾，如果有几个对象相互引用形成环，那也是垃圾）</p></li> <li><p>如何捡垃圾（<strong>标记清除法和引用计数法</strong>）</p> <p>（遍历和计数，只是不同的算法而已）（从全局作用域开始，把所有遇到的变量都标记一下，如果这些变量引用了其他变量，那就再标记，直到早不到新的对象。标记完后将所有没有标记的对象清除掉）（另一种方法计数标记法，引用与否加1减1）</p> <p>https://www.nowcoder.com/interview/ai/report?roomId=244768</p></li></ol> <h3 id="如何捕获js中的异常"><a href="#如何捕获js中的异常" class="header-anchor">#</a> 如何捕获JS中的异常</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">try</span><span class="token punctuation">{</span>
	<span class="token comment">//todo</span>
<span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>ex<span class="token punctuation">)</span><span class="token punctuation">{</span>
	console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>ex<span class="token punctuation">)</span>  <span class="token comment">//手动捕获</span>
<span class="token punctuation">}</span><span class="token keyword">finally</span><span class="token punctuation">{</span>
	<span class="token comment">//todo</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//自动捕获</span>
window<span class="token punctuation">.</span><span class="token function-variable function">onerror</span><span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">message<span class="token punctuation">,</span>source<span class="token punctuation">,</span>lineNum<span class="token punctuation">,</span>colNum<span class="token punctuation">,</span>error</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token comment">//第一，对于跨域的js，如cdn的，不会有详细的报错信息</span>
	<span class="token comment">//第二，对于压缩的js，还要配合sourceMap反查到未压缩的代码的行列</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="requestanimationframe的优势是什么？"><a href="#requestanimationframe的优势是什么？" class="header-anchor">#</a> requestAnimationFrame的优势是什么？</h3> <p>浏览器可以优化并行的动画动作，更合理的重新排列动作序列，并把能够合并的动作放在一个渲染周期内完成，从而呈现出更流畅的动画效果，节省CPU。
应用场景：游戏、动画</p> <p>告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。不需要设置时间间隔，是由系统的时间间隔定义的。大多数浏览器的刷新频率是60Hz(每秒钟反复绘制60次)，循环间隔是1000/60，约等于16.7ms。不需要调用者指定帧速率，<strong>浏览器会自行决定最佳的帧效率</strong>。只被执行一次，这样就不会引起丢帧现象，也不会导致动画出现卡顿的问题。</p> <p><strong>语法</strong>：</p> <div class="language-js extra-class"><pre class="language-js"><code>window<span class="token punctuation">.</span><span class="token function">requestanimationframe</span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">参数callback：下一次重绘之前更新动画帧所调用的函数</span><span class="token punctuation">(</span>即上面所说的回调函数<span class="token punctuation">)</span>。
</code></pre></div><p><strong>范例</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> start <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> element <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'SomeElementYouWantToAnimate'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
element<span class="token punctuation">.</span>style<span class="token punctuation">.</span>position <span class="token operator">=</span> <span class="token string">'absolute'</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">step</span><span class="token punctuation">(</span><span class="token parameter">timestamp</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>start<span class="token punctuation">)</span> start <span class="token operator">=</span> timestamp<span class="token punctuation">;</span>
  <span class="token keyword">var</span> progress <span class="token operator">=</span> timestamp <span class="token operator">-</span> start<span class="token punctuation">;</span>
  element<span class="token punctuation">.</span>style<span class="token punctuation">.</span>left <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>progress <span class="token operator">/</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'px'</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>progress <span class="token operator">&lt;</span> <span class="token number">2000</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    window<span class="token punctuation">.</span><span class="token function">requestAnimationFrame</span><span class="token punctuation">(</span>step<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

window<span class="token punctuation">.</span><span class="token function">requestAnimationFrame</span><span class="token punctuation">(</span>step<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="js为啥是单线程的"><a href="#js为啥是单线程的" class="header-anchor">#</a> JS为啥是单线程的</h3> <p>JavaScript语言的一大特点是单线程，也就是说，<strong>同一时间只能做一件事情</strong>。</p> <p>这与它的用途有关，作为浏览器脚本语言，JavaScript 的主要用途是与用户互动，以及操作DOM，这决定了它只能是单线程，否则会带来很复杂的同步问题。</p> <p>比如，假如JavaScript同时有两个线程，一个线程在某个DOM节点上添加了内容，而另一个线程删除了该节点，这时浏览器应该以哪个线程为准？</p> <h3 id="说一下事件循环-event-loop-？"><a href="#说一下事件循环-event-loop-？" class="header-anchor">#</a> 说一下事件循环(Event Loop)？</h3> <ul><li><strong><code>js</code> 是单线程的</strong>，所以一次只能执行一个任务，当一个任务需要很长时间时，主线程一直等待任务的执行完成，在执行下个任务是很浪费资源的。</li> <li>JavaScript在处理异步操作时，利用的是<strong>事件循环机制。</strong></li></ul> <p><strong>其执行的顺序是这样的：</strong>（背下来）</p> <ol><li>首先 JavaScript 引擎会执行一个宏任务，注意这个宏任务一般是指主干代码本身，也就是目前的同步代码</li> <li>执行过程中如果遇到微任务，就把它添加到微任务任务队列中</li> <li>宏任务执行完成后，立即执行当前微任务队列中的微任务，直到微任务队列被清空</li> <li>微任务执行完成后，开始执行下一个宏任务</li> <li>如此循环往复，直到宏任务和微任务被清空</li></ol> <p>所以，<code>js</code>中任务就被分成两种，一种是同步任务，一种是异步任务。执行步骤如下图所示：</p> <p><img src="https://user-gold-cdn.xitu.io/2019/6/23/16b83ece9d14eab0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p> <p>为了更精细的区分任务，<code>js</code>中可以将异步任务划分为宏任务和微任务。
<strong>宏任务（macro-task）</strong>: 同步 script (整体代码)，setTimeout 回调函数, setInterval 回调函数, ajax请求回调
<strong>微任务（micro-task）</strong>: process.nextTick, Promise 回调函数，Object.observe，MutationObserver</p> <p>Node.js也是单线程的Event Loop，但是它的运行机制不同于浏览器环境。</p> <h3 id="类数组与数组的区别"><a href="#类数组与数组的区别" class="header-anchor">#</a> 类数组与数组的区别</h3> <p>类数组是一个普通对象，真实的数组是Array类型</p> <p>类数组拥有length属性，不具备数组所具有的方法</p> <p><strong>三种转换方法</strong></p> <ul><li><code>Array.prototype.slice.call(arrayLike)</code></li> <li>[...arrayLike]</li> <li>Array.from(arrayLike)</li></ul> <h3 id="箭头函数和普通函数的区别"><a href="#箭头函数和普通函数的区别" class="header-anchor">#</a> 箭头函数和普通函数的区别</h3> <ul><li>箭头函数不会创建自己的this</li> <li>箭头函数继承而来的this指向永远不变</li> <li>.call()/.apply()/.bind()无法改变箭头函数中this的指向</li> <li>箭头函数不能作为构造函数的,不能使用new</li> <li>箭头函数不绑定arguments,取而代之用rest参数…解决</li> <li>箭头函数没有原型属性prototype</li> <li>箭头函数不能用作Generator函数，不能使用yeild关键字</li></ul> <h3 id="如何判断两个数组相同"><a href="#如何判断两个数组相同" class="header-anchor">#</a> 如何判断两个数组相同</h3> <p><strong>方法一：</strong></p> <p>先排序，再利用  <code>toString()</code>  方法</p> <p><strong>方法二：</strong></p> <p>借助JSON的 <code>stringify()</code> 方法</p> <h3 id="如何判断两个对象相同"><a href="#如何判断两个对象相同" class="header-anchor">#</a> 如何判断两个对象相同</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">deepEqual</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> y</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 指向同一内存时</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">===</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> x <span class="token operator">==</span> <span class="token string">&quot;object&quot;</span> <span class="token operator">&amp;&amp;</span> x <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> y <span class="token operator">==</span> <span class="token string">&quot;object&quot;</span> <span class="token operator">&amp;&amp;</span> y <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">.</span>length <span class="token operator">!=</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">)</span>
      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
 
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> prop <span class="token keyword">in</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>y<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>prop<span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token punctuation">{</span>  
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span> <span class="token function">deepEqual</span><span class="token punctuation">(</span>x<span class="token punctuation">[</span>prop<span class="token punctuation">]</span><span class="token punctuation">,</span> y<span class="token punctuation">[</span>prop<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
          <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">else</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
 
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">else</span> 
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="判断一个数组"><a href="#判断一个数组" class="header-anchor">#</a> 判断一个数组</h3> <ul><li><p>instanceof操作符</p></li> <li><p>对象的constructor属性</p></li> <li><p>Object.prototype.toString</p></li> <li><p>Array.isArray()</p></li></ul> <h3 id="js中遍历对象和遍历数组的方法"><a href="#js中遍历对象和遍历数组的方法" class="header-anchor">#</a> js中遍历对象和遍历数组的方法</h3> <p>数组：</p> <ul><li>普通for</li> <li>forEach</li> <li>map</li> <li>for in</li> <li>for of        ES6新增功能，支持数组，类数组，字符串</li></ul> <p>对象</p> <ul><li>for in （主要用于遍历对象的可枚举属性，包括自有属性、继承自原型的属性）</li> <li>Object.keys      (此方法返回一个数组，元素均为对象自有可枚举的属性)</li> <li>Object.getOwnPropertyNames     (此方法用于返回对象的自有属性，包括可枚举和不可枚举的属性)</li></ul> <h3 id="实现图片懒加载的原理"><a href="#实现图片懒加载的原理" class="header-anchor">#</a> 实现图片懒加载的原理</h3> <p>1.首先,不要将图片地址放到src属性中,而是放到其它属性(data-src)中</p> <p>2.页面加载完成后,根据scrollTop判断图片是否在用户的视野内,如果在,则将data-original属性中的值取出存放到src属性中</p> <p>3.在滚动事件中重复判断图片是否进入视野;如果进入,则将data-original属性中的值取出存放到src属性中</p> <h3 id="js输出信息的5种方式"><a href="#js输出信息的5种方式" class="header-anchor">#</a> JS输出信息的5种方式</h3> <div class="language- extra-class"><pre class="language-text"><code>alert()方法
confirm()方法
conlose.log()方法
document.write()方法
prompt()方法
</code></pre></div><h3 id="实现数组相加的方法"><a href="#实现数组相加的方法" class="header-anchor">#</a> 实现数组相加的方法</h3> <p>方法一：</p> <div class="language- extra-class"><pre class="language-text"><code>function sum(arr){
   return eval(arr.join('+'));
}
</code></pre></div><p>方法二：各种遍历，forEach遍历：</p> <p>方法三：reduce</p> <div class="language- extra-class"><pre class="language-text"><code>function sumArr(arr){
        return arr.reduce(function(prev,cur){
            return prev + cur;
        },0);
}
//reduce方法有两个参数，一个是callbackfunction(回调函数)，
//二是设置prev的初始类型和初始值
</code></pre></div></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/vuepress-test/front/CSS.html" class="prev">
        CSS
      </a></span> <span class="next"><a href="/vuepress-test/front/DOM.html">
        DOM
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/vuepress-test/assets/js/app.a9af0fa8.js" defer></script><script src="/vuepress-test/assets/js/2.f1d8a5fb.js" defer></script><script src="/vuepress-test/assets/js/14.b4fced57.js" defer></script>
  </body>
</html>
