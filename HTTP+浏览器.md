## HTTP/浏览器

### HTTP 状态码知道哪些？分别什么意思？

2XX 成功

* 200 OK
* 204 No Content
* 206 Partial Content 

3XX 重定向

* 301 永久重定向
* 302 临时重定向
* 304 资源未修改

4XX 客户端错误

* 400 请求报文中有语法错误
* 403 服务器拒绝访问
* 404 资源未找到

5XX 服务器错误

* 500 仅仅告诉你服务器出错了，出了啥错咱也不知道
* 502 错误网关，无效响应
* 503 服务器忙碌无法响应



### HTTPS与HTTP的一些区别

- HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。
- HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的。
- HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
- HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题。



### HTTP2.0的特性

* 内容安全：http2.0是基于https的

* 二进制格式：http1.X的解析是基于文本的，http2.0将所有的传输信息分割为更小的消息和帧，并对他们采用二进制格式编码
* 多路复用——只需一个连接即可实现并行



### TCP建立连接的三次握手过程⭐ 


**三次握手**：

- 首先服务器端处于LISTEN状态。 
- 当客户端想要建立连接时，他将发送一个SYN包，序列号假如为x。客户端进入SYN_SENT状态。 
- 当服务器端收到了这个SYN包，如果服务器同意建立连接，他将发送一个SYN，ACK包，序列号假如为y，确认号为x+1。服务器端进入SYN_RECD状态。 
- 当客户端收到了服务器端的SYN,ACK包，它将再次确认，向服务器发送一个ACK包，序列号为x+1，确认号为y+1。此时客户端进入ESTABLISHED状态。 
- 当服务器端收到了客户端的ACK包，也将进入ESTABLISHED状态。



### 断开链接四次挥手⭐ 

**第一次握手**

若客户端 A 认为数据发送完成，则它需要向服务端 B 发送连接释放请求。

**第二次握手**

B 收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明 A 到 B 的连接已经释放，不再接收 A 发的数据了。但是因为 TCP 连接是双向的，所以 B 仍旧可以发送数据给 A。

**第三次握手**

B 如果此时还有没发完的数据会继续发送，完毕后会向 A 发送连接释放请求，然后 B 便进入 LAST-ACK 状态。

**第四次握手**

A 收到释放请求后，向 B 发送确认应答，此时 A 进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有 B 的重发请求的话，就进入 CLOSED 状态。当 B 收到确认应答后，也便进入 CLOSED 状态。



### TLS 握手过程

阮一峰的例子：

客户端：爱丽丝   、  服务端：鲍勃

* 第一步，爱丽丝给出协议版本号、一个客户端生成的随机数（Client random），以及客户端支持的加密方法。

* 第二步，鲍勃确认双方使用的加密方法，并给出数字证书、以及一个服务器生成的随机数（Server random）。

* 第三步，爱丽丝确认数字证书有效，然后生成一个新的随机数（Premaster secret），并使用数字证书中的公钥，加密这个随机数，发给鲍勃。

* 第四步，鲍勃使用自己的私钥，获取爱丽丝发来的随机数（即Premaster secret）。

* 第五步，爱丽丝和鲍勃根据约定的加密方法，使用前面的三个随机数，生成"对话密钥"（session key），用来加密接下来的整个对话过程。



### GET 和 POST 的区别

语义上的区别，get用于获取数据，post用于提交数据。

* Post多用于副作用（对服务器的资源进行改变），Get多用于无副作用

* Post 相对 Get 安全一点点，因为GET请求的数据会附在URL之后，以?分割URL和传输数据，参数之间以&相连，

  POST把提交的数据则放置在是HTTP包的包体中。

* GET的长度受限于url的长度，而url的长度限制是特定的浏览器和服务器设置的，理论上GET的长度可以无限长。

* Post 支持更多的编码类型且不对数据类型限制，GET 只能进行 URL 编码，只能接收 ASCII 字符

* 私密性的信息请求使用post，查询信息和可以想要通过url分享的信息使用get。



### 跨域及解决办法

浏览器遵循**同源政策**（scheme(协议)、host(主机)和port(端口)都相同则为同源）

当浏览器向目标 `URI `发` Ajax` 请求时，只要当前 `URL` 和目标 `URL` 不同源，则产生跨域，被称为**跨域请求**。

**目的** 主要是用来防止 CSRF 攻击的。简单点说，CSRF 攻击是利用用户的登录态发起恶意请求。

**解决**

1. jsonp ，允许 script 加载第三方资源    只支持get
2. 反向代理（nginx 服务内部配置 Access-Control-Allow-Origin *）
3. cors 前后端协作设置请求头部，Access-Control-Allow-Origin 等头部信息
4. iframe 嵌套通讯，postmessage



### 有几种方式可以实现存储功能，分别有什么优缺点？

| 特性         | **cookie**                                 | **localStorage**         | **sessionStorage** | **indexDB**              |
| ------------ | ------------------------------------------ | ------------------------ | ------------------ | ------------------------ |
| 数据生命周期 | 一般由服务器生成，可以设置过期时间         | 除非被清理，否则一直存在 | 页面关闭就清理     | 除非被清理，否则一直存在 |
| 数据存储大小 | 4K                                         | 5M                       | 5M                 | 无限                     |
| 与服务端通信 | 每次都会携带在 header 中，对于请求性能影响 | 不参与                   | 不参与             | 不参与                   |


### **Web storage和cookie的区别**

1、Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小是受限的，并且每次你请求一个新的页面的时候Cookie都会被发送过去，这样无形中浪费了带宽，另外cookie还需要指定作用域，不可以跨域调用。
2、除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要前端开发者自己封装setCookie，getCookie。
3、但是cookie也是不可以或缺的：cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生。

### 简单描述一次Http的请求过程

域名解析 –> 发起TCP的3次握手 –> 建立TCP连接后发起http请求 –> 服务器响应http请求，浏览器得到html代码 –> 浏览器解析html代码，并请求html代码中的资源（如js、css、图片等） –> 浏览器对页面进行渲染呈现给用户



### 从输入url到渲染出页面的整个过程

**加载过程**

* `DNS`解析：域名 --> IP地址

* 浏览器根据IP地址向服务器发起`http`请求

* 服务器处理`http`请求，并返回给浏览器

**渲染过程1**

* 根据`HTML`代码生成`DOM Tree`

* 根据`CSS`代码生成`CSSOM`

* 将`DOM Tree`和`CSSOM`整合形成`Render Tree`

**渲染过程2**

* 根据`Render Tree`渲染页面

* 遇到`<script>`则暂停渲染，优先加载并执行JS代码，完成再继续

* 直至把`Render Tree`渲染完成



### DNS域名解析的过程

解析流程就是**分级查询**！

###### 以[www.qq.com为例:

- 客户端打开浏览器，输入一个域名。比如输入[www.163.com]，这时，客户端会发出一个DNS请求到本地DNS服务器。本地DNS服务器一般都是你的网络接入服务器商提供，比如中国电信，中国移动。
- 查询[www.163.com]的DNS请求到达本地DNS服务器之后，本地DNS服务器会首先查询它的缓存记录，如果缓存中有此条记录，就可以直接返回结果。如果没有，本地DNS服务器还要向DNS根服务器进行查询。
- 根DNS服务器没有记录具体的域名和IP地址的对应关系，而是告诉本地DNS服务器，你可以到域服务器上去继续查询，并给出域服务器的地址。
- 本地DNS服务器继续向域服务器发出请求，在这个例子中，请求的对象是.com域服务器。.com域服务器收到请求之后，也不会直接返回域名和IP地址的对应关系，而是告诉本地DNS服务器，你的域名的解析服务器的地址。
- 最后，本地DNS服务器向域名的解析服务器发出请求，这时就能收到一个域名和IP地址对应关系，本地DNS服务器不仅要把IP地址返回给用户电脑，还要把这个对应关系保存在缓存中，以备下次别的用户查询时，可以直接返回结果，加快网络访问。







### 浏览器渲染原理

* 浏览器解析接收到 `HTML` 文件并转换为 `DOM` 树，此操作将确定节点的父子以及兄弟关系。
* 将 `CSS` 文件转换为 `CSSOM` 树，确定css属性之间的级联关系。
* 生成 `DOM` 树和 `CSSOM` 树以后，就需要将这两棵树组合为渲染树。
* 当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流），然后调用 `GPU` 绘制，合成图层，显示在屏幕上。


### 重绘（Repaint）和回流（Reflow）⭐ 

* 重绘是当节点需要更改外观而不会影响布局的，比如改变 `color` 就叫称为重绘

* 回流是布局或者几何属性需要改变就称为回流。

回流**必定**会发生重绘，重绘**不一定**会引发回流。回流所需的成本比重绘高的多，改变父节点里的子节点很可能会导致父节点的一系列回流

**减少重绘和回流(能记多少是多少)**

- **使用 `transform` 替代 `top`**
- **使用 `visibility` 替换 `display: none`** ，因为前者只会引起重绘，后者会引发回流（改变了布局
- **避免使用`table`布局**，可能很小的一个小改动会造成整个 `table` 的重新布局。
- **尽可能在`DOM`树的最末端改变`class`**，回流是不可避免的，但可以减少其影响。尽可能在DOM树的最末端改变class，可以限制了回流的范围，使其影响尽可能少的节点。
- **避免设置多层内联样式**，CSS 选择符**从右往左**匹配查找，避免节点层级过多。
- **将动画效果应用到`position`属性为`absolute`或`fixed`的元素上**，避免影响其他元素的布局
- **避免使用`CSS`表达式**，可能会引发回流。
- **CSS3 硬件加速（GPU加速）**

- **避免频繁操作样式**，最好一次性重写`style`属性，或者将样式列表定义为`class`并一次性更改`class`属性。
- **避免频繁操作`DOM`**，创建一个`documentFragment`，在它上面应用所有`DOM操作`，最后再把它添加到文档中。
- **避免频繁读取会引发回流/重绘的属性**，如果确实需要多次使用，就用一个变量缓存起来。



### 浏览器缓存的读取规则⭐ 

它们的**优先级**是：(由上到下寻找，找到即返回；找不到则继续)

1. Service Worker
2. Memory Cache（内存中的缓存）
3. Disk Cache（硬盘中的缓存）
4. 网络请求

####  强缓存：

不会向服务器发送请求，直接从缓存中读取资源，状态码200。

强缓存可以通过设置两种 HTTP Header 实现：`Expires` 和 `Cache-Control` 。

`Expires`设置一个日期，资源会过期，但受限于本地时间

`Cache-Control：max-age=30`  资源会在30秒后过期

####  协商缓存：

当强制缓存失效(超过规定时间)时，就需要使用对比缓存，由服务器决定缓存内容是否失效。

流程上说，浏览器先请求缓存数据库，返回一个缓存标识。之后浏览器拿这个标识和服务器通讯。如果缓存未失效，则返回 HTTP 状态码 304 表示继续使用，于是客户端继续使用缓存；如果失效，则返回新的数据和缓存规则，浏览器响应数据后，再把规则写入到缓存数据库。

对比缓存有 2 组字段(不是两个)：

**Last-Modified & If-Modified-Since**

1. 服务器通过 `Last-Modified` 字段告知客户端，资源最后一次被修改的时间

2. 下一次请求相同资源时时，浏览器从自己的缓存中找出“不确定是否过期的”缓存。因此在请求头中将上次的 `Last-Modified` 的值写入到请求头的 `If-Modified-Since` 字段

3. 服务器会将 `If-Modified-Since` 的值与 `Last-Modified` 字段进行对比。如果相等，则表示未修改，响应 304；反之，则表示修改了，响应 200 状态码，并返回数据。

但是他还是有一定缺陷的：

- 如果资源更新的速度是秒以下单位，那么该缓存是不能被使用的，因为它的时间单位最低是秒。
- 如果文件是通过服务器动态生成的，那么该方法的更新时间永远是生成的时间，尽管文件可能没有变化，所以起不到缓存的作用。

**Etag & If-None-Match**

为了解决上述问题，出现了一组新的字段 `Etag` 和 `If-None-Match`

`Etag` 存储的是文件的特殊标识(一般都是 hash 生成的)，服务器存储着文件的 `Etag` 字段。之后的流程和 `Last-Modified` 一致，只是 `Last-Modified` 字段和它所表示的更新时间改变成了 `Etag` 字段和它所表示的文件 hash，把 `If-Modified-Since` 变成了 `If-None-Match`。服务器同样进行比较，命中返回 304, 不命中返回新资源和 200。

**Etag 的优先级高于 Last-Modified**


### TCP和UDP的区别(位于传输层)

- 1.UDP
  - 1.无连接
  - 2.面向报文，只是报文的搬运工
  - 3.不可靠，没有拥塞控制
  - 4.高效，头部开销只有8字节
  - 5.支持一对一、一对多、多对多、多对一
  - 6.适合直播、视频、语音、会议等实时性要求高的
- 2.TCP
  - 1.面向连接：传输前需要先连接
  - 2.可靠的传输
  - 3.流量控制：发送方不会发送速度过快，超过接收方的处理能力
  - 4.拥塞控制：当网络负载过多时能限制发送方的发送速率
  - 5.不提供时延保障
  - 6.不提供最小带宽保障

总结：**面向无连接  不可靠性  高效**



### OSI七层模型

osi七层模型可以说是面试必考基础了    **物理系有一个人叫数据链路在网络上传输了一个会话来表示应用**

从上到下分别是：

应用层：特定应用的协议（电子邮件协议，远程登录协议，文件传输协议）

表示层：数据格式转换

会话层：建立，解除会话

传输层：可靠传输

网络层：将数据传送到目标地址

数据链路层：物理层面上的通信传输

物理层：负责0,1比特流与电压高低，光的闪灭之间的互换



TCP/IP模型四层架构从下到上分别是链路层，网络层，传输层，应用层




### window.onload 和 DOMContentLoaded 的区别

在js中DOMContentLoaded方法是在HTML文档被完全的加载和解析之后才会触发的事件，他并不需要等到（样式表/图像/子框架）加载完成之后再进行。在看load事件（onload事件），用于检测一个加载完全的页面


